// Import helper functions to be tested or used in tests
const { 
    buildFeedData, 
    generateRssFeed, 
    generateAtomFeed, 
    generateJsonFeedObject, 
    generateMarkdown, 
    escapeMarkdown, 
    escapeXmlMinimal, 
    fetchUrlContent, 
    parseXmlFeedWithCheerio, 
    normalizeParsedFeed,
    processMultipleUrls 
} = require('./helper');
const { format, formatISO, parseISO, isValid } = require('date-fns');

// Define a fixed point in time for mocking 'now'
const MOCK_NOW_TIMESTAMP = new Date('2025-04-03T10:30:00.000Z').getTime();
const MOCK_NOW_DATE = new Date(MOCK_NOW_TIMESTAMP);

// Mock Date constructor and Date.now() for consistent fallback dates
beforeAll(() => {
  jest.useFakeTimers();
  jest.setSystemTime(MOCK_NOW_DATE);
});

afterAll(() => {
  jest.useRealTimers();
});

// --- Mock Input Data ---
const mockSheetTitle = 'Test Sheet <Title>'; 
const mockSheetID = 'TEST_SHEET_ID_123';
const mockRequestUrl = 'https://crssnt.com/sheetToRss?id=TEST_SHEET_ID_123&name=Sheet1&name=Sheet2';

const mockSheet1Values = [
    ['Title 1 (S1)', 'Desc A', 'https://example.com/1', '2025-04-02T09:00:00Z'], 
    ['Title 3 No Date (S1)', 'Desc C', undefined, null], // Added undefined link for thoroughness 
];
const mockSheet2Values = [
    ['Title 2 (S2)', 'Desc B', 'https://example.com/2', '2025-04-01T08:00:00Z'], 
    ['Title 4 Latest (S2)', 'Desc D', 'https://example.com/4', '2025-04-03T10:00:00Z'], 
];
const mockSheetValuesManual = [
    ['Title', 'URL', 'Summary', 'Published', 'Category', 'Author Name'], 
    ['Manual Title 1', 'https://example.com/m1', 'Manual Desc 1', '2025-04-01T12:00:00Z', 'Tech', 'Alice'], 
    ['Manual Title 2', 'https://example.com/m2', 'Manual Desc 2 & Special', '2025-04-02T12:00:00Z', 'News', 'Bob'], 
    ['Manual Title 3 No Date', 'https://example.com/m3', 'Manual Desc 3', '', 'Tech', 'Charlie'], 
];
const mockSingleSheetAutoData = { 'Sheet1': mockSheet1Values };
const mockSingleSheetManualData = { 'Sheet3': mockSheetValuesManual }; 
const mockMultiSheetAutoData = {
    'Sheet1': mockSheet1Values,
    'Sheet2': mockSheet2Values
};
const mockSheetValuesManualNoTitleValue = [
    ['Link', 'Description', 'Title', 'pubDate'], 
    ['https://example.com/item1', 'Desc 1', 'Valid Title 1', '2025-04-01T12:00:00Z'], 
    ['https://example.com/item2', 'Desc 2', '', '2025-04-02T12:00:00Z'], 
    ['https://example.com/item3', 'Desc 3', 'Valid Title 3', '2025-04-03T12:00:00Z'] 
];
const mockSheetValuesManualNoTitleHeader = [
    ['Link', 'Description', 'NotTheTitle', 'pubDate'], 
    ['https://example.com/item1', 'Desc 1', 'Some Value 1', '2025-04-01T12:00:00Z'],
    ['https://example.com/item2', 'Desc 2', 'Some Value 2', '2025-04-02T12:00:00Z']
];
const mockSheetValuesManualEmptyRow = [
    ['Title', 'Link'], 
    ['Valid Title 1', 'https://example.com/1'],
    ['', null], 
    ['  ', ' '], 
    ['Valid Title 2', 'https://example.com/2'],
];


// --- Tests for buildFeedData (Sheet processing) ---
describe('buildFeedData (Helper Function - Sheet Processing)', () => {
    describe('Auto Mode', () => {
        const mode = 'auto';
        const feedData = buildFeedData(mockSingleSheetAutoData, mode, mockSheetTitle, mockSheetID, mockRequestUrl);
        const items = feedData.items;

        it('should return the correct metadata structure', () => {
            expect(feedData.metadata.title).toBe(mockSheetTitle);
            expect(feedData.metadata.link).toBe(`https://docs.google.com/spreadsheets/d/${mockSheetID}`);
            expect(feedData.metadata.feedUrl).toBe(mockRequestUrl);
            expect(feedData.metadata.description).toBe('Feed from Google Sheet (auto mode). Generated by crssnt.');
            expect(feedData.metadata.id).toBe(`urn:google-sheet:${mockSheetID}`);
            const expectedLatestDate = parseISO('2025-04-02T09:00:00Z');
            expect(feedData.metadata.lastBuildDate.getTime()).toBe(expectedLatestDate.getTime());
        });

        it('should return the correct number of item objects', () => {
            expect(Array.isArray(items)).toBe(true);
            expect(items.length).toBe(2);
        });

        it('should sort items correctly by date (descending)', () => {
            expect(items[0].title).toBe('Title 1 (S1)'); 
            expect(items[1].title).toBe('Title 3 No Date (S1)'); 
        });
    });

    describe('Manual Mode', () => {
        const mode = 'manual';
        const feedData = buildFeedData(mockSingleSheetManualData, mode, mockSheetTitle, mockSheetID, mockRequestUrl);
        const items = feedData.items;

         it('should return the correct metadata structure', () => {
            expect(feedData.metadata.title).toBe(mockSheetTitle);
            expect(feedData.metadata.description).toBe('Feed from Google Sheet (manual mode). Generated by crssnt.');
            expect(feedData.metadata.lastBuildDate.getTime()).toBe(parseISO('2025-04-02T12:00:00Z').getTime());
        });

        it('should return the correct number of item objects', () => {
            expect(Array.isArray(items)).toBe(true);
            expect(items.length).toBe(3); 
        });

        it('should map aliases and custom headers to item properties (sorted)', () => {
            expect(items[0].title).toBe('Manual Title 2');
            expect(items[0].link).toBe('https://example.com/m2'); 
            expect(items[0].descriptionContent).toBe('Manual Desc 2 & Special'); 
            expect(items[0].dateObject?.toISOString()).toBe('2025-04-02T12:00:00.000Z'); 
            expect(items[0].customFields).toBeDefined();
            expect(items[0].customFields['Category']).toBe('News'); 
            expect(items[0].customFields['Author_Name']).toBe('Bob'); 

            expect(items[1].title).toBe('Manual Title 1');
            expect(items[1].dateObject?.toISOString()).toBe('2025-04-01T12:00:00.000Z');
            expect(items[1].customFields).toBeDefined();
            expect(items[1].customFields['Category']).toBe('Tech');
            expect(items[1].customFields['Author_Name']).toBe('Alice');

             expect(items[2].title).toBe('Manual Title 3 No Date');
             expect(items[2].dateObject).toBeNull();
             expect(items[2].customFields).toBeDefined();
             expect(items[2].customFields['Category']).toBe('Tech');
             expect(items[2].customFields['Author_Name']).toBe('Charlie');
        });

         it('should handle missing date in manual mode', () => {
             const feedDataNoDate = buildFeedData({ 'SheetX': mockSheetValuesManual }, mode, mockSheetTitle, mockSheetID, mockRequestUrl);
             const item3 = feedDataNoDate.items[2];
             expect(item3.title).toBe('Manual Title 3 No Date');
             expect(item3.link).toBe('https://example.com/m3');
             expect(item3.descriptionContent).toBe('Manual Desc 3');
             expect(item3.dateObject).toBeNull(); 
        });

        it('should use placeholder title if title value is missing in manual mode', () => {
            const feedDataNoTitleValue = buildFeedData({ 'SheetX': mockSheetValuesManualNoTitleValue }, mode, mockSheetTitle, mockSheetID, mockRequestUrl);
            const itemsNoTitleValue = feedDataNoTitleValue.items;

            expect(itemsNoTitleValue).toHaveLength(3);
            expect(itemsNoTitleValue[0].title).toBe('Valid Title 3'); 
            expect(itemsNoTitleValue[1].title).toBe('(Untitled)'); 
            expect(itemsNoTitleValue[2].title).toBe('Valid Title 1'); 

            const itemWithPlaceholder = itemsNoTitleValue[1]; 
            expect(itemWithPlaceholder.title).toBe('(Untitled)');
            expect(itemWithPlaceholder.link).toBe('https://example.com/item2');
            expect(itemWithPlaceholder.descriptionContent).toBe('Desc 2');
            expect(itemWithPlaceholder.dateObject?.toISOString()).toBe('2025-04-02T12:00:00.000Z');
        });

        it('should use placeholder title if "title" header is missing in manual mode', () => {
            const feedDataNoTitleHeader = buildFeedData({ 'SheetX': mockSheetValuesManualNoTitleHeader }, mode, mockSheetTitle, mockSheetID, mockRequestUrl);
            const itemsNoTitleHeader = feedDataNoTitleHeader.items;

            expect(itemsNoTitleHeader).toHaveLength(2);
            expect(itemsNoTitleHeader[0].title).toBe('(Untitled)');
            expect(itemsNoTitleHeader[0].link).toBe('https://example.com/item2'); 
            expect(itemsNoTitleHeader[0].dateObject?.toISOString()).toBe('2025-04-02T12:00:00.000Z');

            expect(itemsNoTitleHeader[1].title).toBe('(Untitled)');
            expect(itemsNoTitleHeader[1].link).toBe('https://example.com/item1');
            expect(itemsNoTitleHeader[1].dateObject?.toISOString()).toBe('2025-04-01T12:00:00.000Z');
        });

        it('should skip rows where all cells are empty or whitespace in manual mode', () => {
             const feedDataEmptyRows = buildFeedData({ 'SheetX': mockSheetValuesManualEmptyRow }, mode, mockSheetTitle, mockSheetID, mockRequestUrl);
             expect(feedDataEmptyRows.items).toHaveLength(2); 
             expect(feedDataEmptyRows.items[0].title).toBe('Valid Title 1'); 
             expect(feedDataEmptyRows.items[1].title).toBe('Valid Title 2'); 
        });
    });

    describe('Sheet Tab Aggregation - Auto Mode', () => {
        const mode = 'auto';
        const feedData = buildFeedData(mockMultiSheetAutoData, mode, mockSheetTitle, mockSheetID, mockRequestUrl);
        const items = feedData.items;

        it('should return combined metadata', () => {
            expect(feedData.metadata.title).toBe(mockSheetTitle);
            expect(feedData.metadata.description).toBe('Feed from Google Sheet (auto mode). Generated by crssnt.');
            const expectedLatestDate = parseISO('2025-04-03T10:00:00Z'); 
            expect(feedData.metadata.lastBuildDate.getTime()).toBe(expectedLatestDate.getTime());
        });

        it('should return the combined number of items from all sheets', () => {
             expect(Array.isArray(items)).toBe(true);
             expect(items.length).toBe(4);
        });

        it('should sort the COMBINED list of items correctly by date (descending)', () => {
            expect(items[0].title).toBe('Title 4 Latest (S2)'); 
            expect(items[1].title).toBe('Title 1 (S1)');         
            expect(items[2].title).toBe('Title 2 (S2)');         
            expect(items[3].title).toBe('Title 3 No Date (S1)'); 
        });
    });
});

// --- Tests for generateRssFeed, generateAtomFeed, generateJsonFeedObject, generateMarkdown ---

describe('generateRssFeed (Helper Function with Aggregated Sheet Data)', () => {
    const feedData = buildFeedData(mockMultiSheetAutoData, 'auto', mockSheetTitle, mockSheetID, mockRequestUrl);
    const resultXml = generateRssFeed(feedData);

    it('should contain channel metadata reflecting aggregation', () => {
        expect(resultXml).toContain(`<title>Test Sheet &lt;Title&gt;</title>`);
        expect(resultXml).toContain(`<description>Feed from Google Sheet (auto mode). Generated by crssnt.</description>`);
        const expectedDate = format(feedData.metadata.lastBuildDate, "EEE, dd MMM yyyy HH:mm:ss 'GMT'", { timeZone: 'GMT' });
        expect(resultXml).toContain(`<lastBuildDate>${expectedDate}</lastBuildDate>`);
    });

    it('should contain the correct total number of items', () => {
         expect(resultXml.match(/<item>/g)?.length).toBe(4);
    });

     it('should contain the latest item first', () => {
        const firstItem = feedData.items[0]; 
        const expectedDate = format(firstItem.dateObject, "EEE, dd MMM yyyy HH:mm:ss 'GMT'", { timeZone: 'GMT' });
        expect(resultXml).toContain(`<title><![CDATA[${firstItem.title}]]></title>`);
        expect(resultXml).toContain(`<pubDate>${expectedDate}</pubDate>`);
    });
});

describe('generateAtomFeed (Helper Function with Aggregated Sheet Data)', () => {
    const feedData = buildFeedData(mockMultiSheetAutoData, 'auto', mockSheetTitle, mockSheetID, mockRequestUrl);
    const resultXml = generateAtomFeed(feedData);

     it('should contain feed metadata reflecting aggregation', () => {
        expect(resultXml).toContain(`<title>Test Sheet &lt;Title&gt;</title>`);
        expect(resultXml).toContain(`<subtitle type="html"><![CDATA[Feed from Google Sheet (auto mode). Generated by crssnt.]]></subtitle>`);
        expect(resultXml).toContain(`<id>${feedData.metadata.id}</id>`); 
        expect(resultXml).toContain(`<updated>${formatISO(feedData.metadata.lastBuildDate)}</updated>`);
    });

    it('should contain the correct total number of entries', () => {
         expect(resultXml.match(/<entry>/g)?.length).toBe(4); 
    });

     it('should contain the latest entry first', () => {
        const firstItem = feedData.items[0]; 
        const expectedDate = formatISO(firstItem.dateObject);
        const expectedId = firstItem.link; 

        expect(resultXml).toContain('<entry>');
        expect(resultXml).toContain(`<title type="html"><![CDATA[${firstItem.title}]]></title>`);
        expect(resultXml).toContain(`<id>${escapeXmlMinimal(expectedId)}</id>`); 
        expect(resultXml).toContain(`<updated>${expectedDate}</updated>`);
        expect(resultXml).toContain('</entry>');
    });
});

describe('generateJsonFeedObject (Helper Function - Sheet Data)', () => {
    const mode = 'auto';
    const feedDataAggregated = buildFeedData(mockMultiSheetAutoData, mode, mockSheetTitle, mockSheetID, mockRequestUrl);
    const resultJson = generateJsonFeedObject(feedDataAggregated, false, false, false); // No grouping, not LLM compact

    it('should contain correct top-level feed properties for aggregated data', () => {
        expect(resultJson.version).toBe('https://jsonfeed.org/version/1.1');
        expect(resultJson.title).toBe(mockSheetTitle); 
        expect(resultJson.home_page_url).toBe(`https://docs.google.com/spreadsheets/d/${mockSheetID}`);
        expect(resultJson.feed_url).toBe(mockRequestUrl);
        expect(resultJson.description).toBe('Feed from Google Sheet (auto mode). Generated by crssnt.');
    });

    it('should contain the correct total number of items', () => {
        expect(Array.isArray(resultJson.items)).toBe(true);
        expect(resultJson.items.length).toBe(4); 
    });

    it('should contain correct properties for the latest item', () => {
        const firstItem = feedDataAggregated.items[0]; 
        const jsonItem = resultJson.items[0];

        // expect(jsonItem.id).toBe(firstItem.link); // ID might be different if no link
        expect(jsonItem.url).toBe(firstItem.link);
        expect(jsonItem.title).toBe(firstItem.title);
        expect(jsonItem.content_text).toBe(firstItem.descriptionContent); // Changed to content_text
        expect(jsonItem.date_published).toBe(formatISO(firstItem.dateObject));
    });
     it('should handle items with no link (generate hashed ID)', () => {
        const itemNoLinkNoDate = feedDataAggregated.items.find(item => item.title === 'Title 3 No Date (S1)');
        const jsonItem = resultJson.items.find(jItem => jItem.title === 'Title 3 No Date (S1)');

        expect(jsonItem).toBeDefined();
        expect(itemNoLinkNoDate).toBeDefined();
        expect(jsonItem.url).toBeUndefined(); 
        expect(jsonItem.title).toBe('Title 3 No Date (S1)');
        expect(jsonItem.content_text).toBe('Desc C'); // Changed to content_text
        // ID is omitted in LLM compact mode, and this test is for non-compact.
        // If ID were present, it would be:
        // expect(jsonItem.id).toMatch(/^urn:google-sheet:TEST_SHEET_ID_123:[a-f0-9]{40}$/);
    });
    it('should include custom fields under _crssnt_custom_fields for manual mode', () => {
        const manualFeedData = buildFeedData(mockSingleSheetManualData, 'manual', 'Manual Sheet', 'MANUAL_ID', 'https://crssnt.com/manual');
        const manualJson = generateJsonFeedObject(manualFeedData, false, false, false);
        const itemWithCustom = manualJson.items.find(item => item.title === 'Manual Title 2');
        expect(itemWithCustom).toBeDefined();
        expect(itemWithCustom._crssnt_custom_fields).toBeDefined();
        expect(itemWithCustom._crssnt_custom_fields.Category).toBe('News');
        expect(itemWithCustom._crssnt_custom_fields.Author_Name).toBe('Bob'); 
    });
    it('should include truncation notice in description if items are limited', () => {
        const limitedFeedData = buildFeedData(mockMultiSheetAutoData, 'auto', mockSheetTitle, mockSheetID, mockRequestUrl, 1, 500); 
        const limitedJson = generateJsonFeedObject(limitedFeedData, false, false, false);
        expect(limitedJson.description).toContain('Note: This feed may be incomplete due to configured limits.');
    });
});

describe('generateMarkdown (Helper Function - Sheet Data)', () => {
    const mode = 'auto';
    const feedDataAggregated = buildFeedData(mockMultiSheetAutoData, mode, mockSheetTitle, mockSheetID, mockRequestUrl);
    const resultMd = generateMarkdown(feedDataAggregated, false, false, false); // No grouping, not LLM compact

    it('should contain the correct total number of items (indicated by separators)', () => {
        const separatorCount = (resultMd.match(/\n---\n\n/g) || []).length;
        expect(separatorCount).toBe(feedDataAggregated.items.length + 1); 
    });

    it('should contain correct content for the latest item', () => {
        const firstItem = feedDataAggregated.items[0]; 
        const expectedPublishedDate = format(firstItem.dateObject, 'PPPppp', { timeZone: 'GMT' });

        expect(resultMd).toContain(`### ${escapeMarkdown(firstItem.title)}`); // Items are H3
        expect(resultMd).toContain(`*Published: ${expectedPublishedDate} (GMT)*`);
        expect(resultMd).toContain(firstItem.descriptionContent);
    });
    it('should handle items with no link and no date correctly', () => {
        const itemNoLinkNoDate = feedDataAggregated.items.find(item => item.title === 'Title 3 No Date (S1)');
        const expectedMarkdownTitle = escapeMarkdown(itemNoLinkNoDate.title);
        expect(resultMd).toContain(`### ${expectedMarkdownTitle}`);
        expect(resultMd).not.toContain(`### ${expectedMarkdownTitle}\n\n*Published:`);
        const regexEscapedMarkdownTitle = expectedMarkdownTitle.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const itemSectionRegex = new RegExp(`### ${regexEscapedMarkdownTitle}[\\s\\S]*?---`);
        const itemSectionMatch = resultMd.match(itemSectionRegex);
        expect(itemSectionMatch).toBeTruthy();
        expect(itemSectionMatch[0]).not.toContain("**Link:**"); // No link for this item
        expect(resultMd).toContain(itemNoLinkNoDate.descriptionContent);
    });
    it('should include custom fields correctly for manual mode', () => {
        const manualFeedData = buildFeedData(mockSingleSheetManualData, 'manual', 'Manual Sheet', 'MANUAL_ID', 'https://crssnt.com/manual');
        const manualMd = generateMarkdown(manualFeedData, false, false, false);
        const itemTitle2 = 'Manual Title 2';
        const escapedItemTitle2 = escapeMarkdown(itemTitle2); 
        const regexEscapedItemTitle2 = escapedItemTitle2.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const item2SectionRegex = new RegExp(`### ${regexEscapedItemTitle2}[\\s\\S]*?---`);
        const item2SectionMatch = manualMd.match(item2SectionRegex);
        expect(item2SectionMatch).toBeTruthy();
        const item2Md = item2SectionMatch[0];
        expect(item2Md).toContain(`**Custom Fields:**`); 
        expect(item2Md).toContain(`* ${escapeMarkdown('Category')}: ${escapeMarkdown('News')}`);
        expect(item2Md).toContain(`* ${escapeMarkdown('Author_Name')}: ${escapeMarkdown('Bob')}`);
    });
    it('should include truncation notice if items are limited', () => {
        const limitedFeedData = buildFeedData(mockMultiSheetAutoData, 'auto', mockSheetTitle, mockSheetID, mockRequestUrl, 1, 500); 
        const limitedMd = generateMarkdown(limitedFeedData, false, false, false);
        expect(limitedMd).toContain(`**Note: This feed may be incomplete due to configured limits.**`);
    });
    it('should handle empty items list gracefully', () => {
        const emptyFeedData = {
            metadata: { title: 'Empty Feed', link: 'http://example.com', feedUrl: 'http://example.com/feed', description: 'An empty feed.' , lastBuildDate: MOCK_NOW_DATE, id:'urn:empty'},
            items: []
        };
        const md = generateMarkdown(emptyFeedData, false, false, false);
        expect(md).toContain("# Empty Feed");
        expect(md).toContain("_No items found._");
    });
});

// --- Mock XML Data for External Feed Parsing ---
const mockRssXmlFeed1 = `<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"><channel>
    <title>RSS Feed Alpha</title>
    <link>https://alpha.example.com</link>
    <description>Alpha items</description>
    <item>
      <title>Alpha Item 2 (Newer)</title>
      <link>https://alpha.example.com/item2</link>
      <description>Desc Alpha 2</description>
      <pubDate>Wed, 05 Apr 2025 10:00:00 GMT</pubDate>
      <guid>alpha2</guid>
    </item>
    <item>
      <title>Alpha Item 1 (Older)</title>
      <link>https://alpha.example.com/item1</link>
      <description>Desc Alpha 1</description>
      <pubDate>Mon, 03 Apr 2025 09:00:00 GMT</pubDate>
      <guid>alpha1</guid>
    </item>
</channel></rss>`;

const mockAtomXmlFeed2 = `<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Atom Feed Beta</title>
  <link href="https://beta.example.com" rel="alternate"/>
  <id>urn:beta</id>
  <updated>2025-04-06T12:00:00Z</updated>
  <entry>
    <title>Beta Item 1 (Newest)</title>
    <link href="https://beta.example.com/entry1"/>
    <id>beta1</id>
    <updated>2025-04-06T12:00:00Z</updated>
    <summary>Summary Beta 1</summary>
  </entry>
  <entry>
    <title>Beta Item 2 (Oldest)</title>
    <link href="https://beta.example.com/entry2"/>
    <id>beta2</id>
    <updated>2025-04-02T15:00:00Z</updated>
    <summary>Summary Beta 2</summary>
  </entry>
</feed>`;

const mockRssXmlFeed3NoDates = `<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"><channel>
    <title>Gamma Feed (No Dates)</title>
    <link>https://gamma.example.com</link>
    <item><title>Gamma Item 1</title><link>https://gamma.example.com/g1</link><description>Gamma desc 1</description></item>
    <item><title>Gamma Item 2</title><link>https://gamma.example.com/g2</link><description>Gamma desc 2</description></item>
</channel></rss>`;


// --- Tests for External Feed Processing (fetchUrlContent, parseXmlFeedWithCheerio, normalizeParsedFeed) ---

describe('fetchUrlContent', () => {
    const originalFetch = global.fetch;
    afterEach(() => {
        global.fetch = originalFetch; 
    });

    it('should fetch and return content for a successful response', async () => {
        global.fetch = jest.fn().mockResolvedValueOnce({
            ok: true,
            text: async () => 'Mocked fetched content',
        });
        const content = await fetchUrlContent('https://example.com/feed.xml');
        expect(fetch).toHaveBeenCalledWith('https://example.com/feed.xml', { headers: { 'User-Agent': 'crssnt-feed-generator/1.0 (+https://crssnt.com)' } });
        expect(content).toBe('Mocked fetched content');
    });

    it('should throw an error for a non-ok response', async () => {
        global.fetch = jest.fn().mockResolvedValueOnce({
            ok: false,
            status: 404,
            statusText: 'Not Found',
        });
        await expect(fetchUrlContent('https://example.com/notfound.xml'))
            .rejects.toThrow('Failed to fetch https://example.com/notfound.xml: 404 Not Found');
    });
});

describe('parseXmlFeedWithCheerio', () => {
    it('should parse a valid XML string and return a Cheerio object', () => {
        const $ = parseXmlFeedWithCheerio(mockRssXmlFeed1); 
        expect($).toBeDefined();
        expect(typeof $.root).toBe('function'); 
        expect($('rss > channel > title').text()).toBe('RSS Feed Alpha');
    });
});

describe('normalizeParsedFeed', () => {
    const sourceUrl = 'https://example.com/source';

    describe('RSS Feed', () => {
        const $ = parseXmlFeedWithCheerio(mockRssXmlFeed1);
        const feedData = normalizeParsedFeed($, sourceUrl);

        it('should extract correct RSS metadata and add sourceInfo to items', () => {
            expect(feedData.metadata.title).toBe('RSS Feed Alpha');
            expect(feedData.metadata.link).toBe('https://alpha.example.com');
            expect(feedData.metadata.lastBuildDate.toISOString()).toBe(parseISO('2025-04-05T10:00:00Z').toISOString());
            expect(feedData.metadata.id).toBe('https://alpha.example.com'); 
            expect(feedData.items[0].sourceInfo).toEqual({ title: 'RSS Feed Alpha', url: sourceUrl, type: 'rss' });
        });

        it('should extract and sort RSS items correctly', () => {
            expect(feedData.items).toHaveLength(2);
            expect(feedData.items[0].title).toBe('Alpha Item 2 (Newer)');
            expect(feedData.items[1].title).toBe('Alpha Item 1 (Older)');
        });
    });

    describe('Atom Feed', () => {
        const $ = parseXmlFeedWithCheerio(mockAtomXmlFeed2);
        const feedData = normalizeParsedFeed($, sourceUrl);

        it('should extract correct Atom metadata and add sourceInfo to items', () => {
            expect(feedData.metadata.title).toBe('Atom Feed Beta');
            expect(feedData.metadata.link).toBe('https://beta.example.com');
            expect(feedData.metadata.lastBuildDate.toISOString()).toBe(parseISO('2025-04-06T12:00:00Z').toISOString());
            expect(feedData.metadata.id).toBe('urn:beta');
            expect(feedData.items[0].sourceInfo).toEqual({ title: 'Atom Feed Beta', url: sourceUrl, type: 'atom' });
        });

        it('should extract and sort Atom entries correctly', () => {
            expect(feedData.items).toHaveLength(2);
            expect(feedData.items[0].title).toBe('Beta Item 1 (Newest)');
            expect(feedData.items[1].title).toBe('Beta Item 2 (Oldest)');
        });
    });
     it('should handle unknown feed type gracefully', () => {
        const $ = parseXmlFeedWithCheerio('<data>not a feed</data>');
        const feedData = normalizeParsedFeed($, 'http://invalid.com/feed');
        expect(feedData.metadata.title).toBe('Unknown or Invalid Feed Type');
        expect(feedData.metadata.description).toContain('Could not determine feed type');
        expect(feedData.items).toHaveLength(0);
        expect(feedData.metadata.lastBuildDate).toBeNull(); 
    });

    it('should use item date for lastBuildDate if feed date is missing', () => {
        const $ = parseXmlFeedWithCheerio(mockRssXmlFeed1); 
        const feedData = normalizeParsedFeed($, sourceUrl);
        expect(feedData.metadata.lastBuildDate.toISOString()).toBe(parseISO('2025-04-05T10:00:00Z').toISOString());
    });
});


// --- Tests for processMultipleUrls (Helper Function - URL Aggregation) ---
describe('processMultipleUrls (Helper Function - URL Aggregation)', () => {
    const mockRequestUrl = 'https://crssnt.com/feedToJson?url=...';
    let originalFetch;

    beforeEach(() => {
        originalFetch = global.fetch; 
    });
    afterEach(() => {
        global.fetch = originalFetch; 
        jest.clearAllMocks();
    });

    it('should combine and sort items from multiple valid feeds (no grouping)', async () => {
        global.fetch = jest.fn((url) => {
            if (url === 'https://alpha.example.com/rss.xml') return Promise.resolve({ ok: true, text: async () => mockRssXmlFeed1 });
            if (url === 'https://beta.example.com/atom.xml') return Promise.resolve({ ok: true, text: async () => mockAtomXmlFeed2 });
            return Promise.resolve({ ok: false, status: 404 });
        });

        const sourceUrls = ['https://alpha.example.com/rss.xml', 'https://beta.example.com/atom.xml'];
        const feedData = await processMultipleUrls(sourceUrls, mockRequestUrl, 50, 500, false); // groupByFeed = false
        
        expect(feedData.items).toHaveLength(4);
        expect(feedData.metadata.title).toBe('Combined Feed from 2 sources');
        expect(feedData.items[0].title).toBe('Beta Item 1 (Newest)');      
        expect(feedData.items[1].title).toBe('Alpha Item 2 (Newer)');     
        expect(feedData.items[2].title).toBe('Alpha Item 1 (Older)');     
        expect(feedData.items[3].title).toBe('Beta Item 2 (Oldest)');      
        expect(feedData.metadata.lastBuildDate.toISOString()).toBe(parseISO('2025-04-06T12:00:00Z').toISOString());
        expect(feedData.metadata.groupByFeed).toBe(false); 
        feedData.items.forEach(item => {
            expect(item.sourceInfo).toBeDefined(); 
        });
    });
    
    it('should combine items and set groupByFeed flag when requested, and not sort globally', async () => {
        global.fetch = jest.fn((url) => {
            if (url === 'https://alpha.example.com/rss.xml') return Promise.resolve({ ok: true, text: async () => mockRssXmlFeed1 }); 
            if (url === 'https://beta.example.com/atom.xml') return Promise.resolve({ ok: true, text: async () => mockAtomXmlFeed2 });   
            return Promise.resolve({ ok: false, status: 404 });
        });
        const sourceUrls = ['https://alpha.example.com/rss.xml', 'https://beta.example.com/atom.xml'];
        const feedData = await processMultipleUrls(sourceUrls, mockRequestUrl, 50, 500, true); // groupByFeed = true

        expect(feedData.items).toHaveLength(4); 
        expect(feedData.metadata.groupByFeed).toBe(true); 
        
        expect(feedData.items[0].title).toBe('Alpha Item 2 (Newer)'); 
        expect(feedData.items[1].title).toBe('Alpha Item 1 (Older)'); 
        expect(feedData.items[2].title).toBe('Beta Item 1 (Newest)');  
        expect(feedData.items[3].title).toBe('Beta Item 2 (Oldest)');  
        
        const expectedLastBuildDate = parseISO('2025-04-06T12:00:00Z'); 
        expect(feedData.metadata.lastBuildDate.getTime()).toBe(expectedLastBuildDate.getTime());

        feedData.items.forEach(item => {
            expect(item.sourceInfo).toBeDefined();
            expect(item.sourceInfo.title).toBeDefined();
            expect(item.sourceInfo.url).toBeDefined();
        });
    });


    it('should handle one failing URL and one successful URL (no grouping)', async () => {
        global.fetch = jest.fn((url) => {
            if (url === 'https://alpha.example.com/rss.xml') return Promise.resolve({ ok: true, text: async () => mockRssXmlFeed1 });
            if (url === 'https://fail.example.com/atom.xml') return Promise.resolve({ ok: false, status: 500, statusText: 'Server Error' });
            return Promise.resolve({ ok: false, status: 404 });
        });
        const sourceUrls = ['https://alpha.example.com/rss.xml', 'https://fail.example.com/atom.xml'];
        const feedData = await processMultipleUrls(sourceUrls, mockRequestUrl, 50, 500, false);
        expect(feedData.items).toHaveLength(2); 
        expect(feedData.items[0].title).toBe('Alpha Item 2 (Newer)');
        expect(feedData.metadata.title).toBe('RSS Feed Alpha'); 
        // Corrected Expectation: When only one feed is successful, the description should be that of the successful feed.
        expect(feedData.metadata.description).toBe('Alpha items'); 
        expect(feedData.metadata.groupByFeed).toBe(false); 
    });

    it('should throw an error if all URLs fail or result in no items', async () => {
        global.fetch = jest.fn(() => Promise.resolve({ ok: false, status: 404, statusText: 'Not Found' }));
        const sourceUrls = ['https://fail1.example.com', 'https://fail2.example.com'];
        await expect(processMultipleUrls(sourceUrls, mockRequestUrl, 50, 500))
            .rejects.toThrow('No valid feed items could be fetched or processed from the provided URLs.');
    });
});

// --- Tests for Output Generators with Grouping and LLM Compact Mode ---
describe('generateJsonFeedObject with LLM Compact Mode', () => {
    let feedDataMultiSourceGrouped;
    const sourceUrl1 = 'https://alpha.example.com/rss.xml';
    const sourceUrl2 = 'https://beta.example.com/atom.xml';

    beforeAll(async () => { 
        global.fetch = jest.fn((url) => {
            if (url === sourceUrl1) return Promise.resolve({ ok: true, text: async () => mockRssXmlFeed1 });
            if (url === sourceUrl2) return Promise.resolve({ ok: true, text: async () => mockAtomXmlFeed2 });
            return Promise.resolve({ ok: false, status: 404 });
        });
        // Ensure groupByFeed is true for these tests
        feedDataMultiSourceGrouped = await processMultipleUrls([sourceUrl1, sourceUrl2], 'https://crssnt.com/combined_grouped', 50, 500, true);
    });
    afterAll(() => {
        jest.restoreAllMocks(); 
    });

    it('should omit top-level metadata and item id in LLM compact mode', () => {
        const jsonResult = generateJsonFeedObject(feedDataMultiSourceGrouped, true, true, true); // isLlmCompact = true
        expect(jsonResult.title).toBeUndefined();
        expect(jsonResult.home_page_url).toBeUndefined();
        expect(jsonResult.feed_url).toBeUndefined();
        expect(jsonResult.description).toBeUndefined();
        expect(jsonResult.language).toBeUndefined();
        expect(jsonResult._crssnt_generator).toBeUndefined();
        jsonResult.items.forEach(item => {
            expect(item.id).toBeUndefined();
            expect(item.date_published).toBeDefined(); // Date should be present
            expect(item.content_text).toBeDefined();
        });
    });

    it('should include item title, url, content_text, and date_published in LLM compact mode', () => {
        const jsonResult = generateJsonFeedObject(feedDataMultiSourceGrouped, true, true, true);
        const firstItem = jsonResult.items[0]; // Alpha Item 2 (Newer)
        expect(firstItem.title).toBe('Alpha Item 2 (Newer)');
        expect(firstItem.url).toBe('https://alpha.example.com/item2');
        expect(firstItem.content_text).toBe('Desc Alpha 2');
        expect(firstItem.date_published).toBe(formatISO(parseISO('2025-04-05T10:00:00Z')));
    });
    
    it('should include simplified _source_feed (title only) in LLM compact mode when grouped', () => {
        const jsonResult = generateJsonFeedObject(feedDataMultiSourceGrouped, true, true, true);
        expect(feedDataMultiSourceGrouped.metadata.groupByFeed).toBe(true);
        jsonResult.items.forEach(item => {
            expect(item._source_feed).toBeDefined();
            expect(item._source_feed.title).toBeDefined();
            expect(item._source_feed.url).toBeUndefined(); // URL omitted for compactness
        });
    });
});

describe('generateMarkdown with LLM Compact Mode', () => {
    let feedDataMultiSourceGrouped, feedDataSingleSource;
    const sourceUrl1 = 'https://alpha.example.com/rss.xml';
    const sourceUrl2 = 'https://beta.example.com/atom.xml';
     const sourceUrl3NoDate = 'https://gamma.example.com/rss.xml';


    beforeAll(async () => {
        global.fetch = jest.fn((url) => {
            if (url === sourceUrl1) return Promise.resolve({ ok: true, text: async () => mockRssXmlFeed1 });
            if (url === sourceUrl2) return Promise.resolve({ ok: true, text: async () => mockAtomXmlFeed2 });
            if (url === sourceUrl3NoDate) return Promise.resolve({ ok: true, text: async () => mockRssXmlFeed3NoDates });
            return Promise.resolve({ ok: false, status: 404 });
        });
        feedDataMultiSourceGrouped = await processMultipleUrls([sourceUrl1, sourceUrl2], 'https://crssnt.com/combined_md_grouped', 2, 500, true); // Limit to 2 items
        feedDataSingleSource = await processMultipleUrls([sourceUrl3NoDate], 'https://crssnt.com/single_md', 50, 500, false); // Not grouped
    });
    afterAll(() => {
        jest.restoreAllMocks();
    });

    it('should produce single-line hierarchical output when grouped and llm_compact is true', () => {
        const mdResult = generateMarkdown(feedDataMultiSourceGrouped, true, true, true); // isLlmCompact = true
        
        // Expected: # Source1 ## Item1 Desc Link Date --- ## Item2 Desc Link Date ||| # Source2 ...
        // Due to itemLimit=2 on processMultipleUrls, and how items are added, we'll get the first two items overall.
        // Alpha Item 2 (Apr 5), Alpha Item 1 (Apr 3) from feed 1. Beta items won't make it due to limit.
        // Actually, processMultipleUrls with groupByFeed=true concatenates then limits. So we get 2 items from Alpha.
        
        const expectedParts = [
            `# RSS Feed Alpha ## Alpha Item 2 (Newer) Desc Alpha 2 Link: https://alpha.example.com/item2 Date: ${formatISO(parseISO('2025-04-05T10:00:00Z'))}`,
            `--- ## Alpha Item 1 (Older) Desc Alpha 1 Link: https://alpha.example.com/item1 Date: ${formatISO(parseISO('2025-04-03T09:00:00Z'))}`
        ];
        expect(mdResult).toBe(expectedParts.join(" ") + " [TRUNCATED]");
    });

    it('should produce single-line hierarchical output when not grouped and llm_compact is true', () => {
        // feedDataSingleSource has 2 items, no dates.
        const mdResult = generateMarkdown(feedDataSingleSource, false, false, true); // isLlmCompact = true, not grouped
        const expected = `# Gamma Item 1 Gamma desc 1 Link: https://gamma.example.com/g1 ||| # Gamma Item 2 Gamma desc 2 Link: https://gamma.example.com/g2`;
        expect(mdResult).toBe(expected);
    });

    it('should include [TRUNCATED] notice if items were limited', () => {
        const mdResult = generateMarkdown(feedDataMultiSourceGrouped, true, true, true);
        expect(mdResult).toContain("[TRUNCATED]");
    });
    
    it('should handle items with no link or no date correctly in compact markdown', async () => {
        const feedDataNoDateLink = await processMultipleUrls([sourceUrl3NoDate], 'reqUrl', 1, 500, false);
        const mdResult = generateMarkdown(feedDataNoDateLink, false, false, true);
        expect(mdResult).toBe("# Gamma Item 1 Gamma desc 1 Link: https://gamma.example.com/g1 [TRUNCATED]");
    });
});
