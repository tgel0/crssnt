// Import helper functions to be tested or used in tests
const { 
    buildFeedData, 
    generateRssFeed, 
    generateAtomFeed, 
    generateJsonFeedObject, 
    generateMarkdown, 
    escapeMarkdown, 
    escapeXmlMinimal,
    fetchUrlContent, 
    parseXmlFeedWithCheerio, 
    normalizeParsedFeed,
    processMultipleUrls // Import the new helper
} = require('./helper');
const { format, formatISO, parseISO, isValid } = require('date-fns');

// Define a fixed point in time for mocking 'now'
const MOCK_NOW_TIMESTAMP = new Date('2025-04-03T10:30:00.000Z').getTime();
const MOCK_NOW_DATE = new Date(MOCK_NOW_TIMESTAMP);

// Mock Date constructor and Date.now() for consistent fallback dates
beforeAll(() => {
  jest.useFakeTimers();
  jest.setSystemTime(MOCK_NOW_DATE);
});

afterAll(() => {
  jest.useRealTimers();
});

// --- Mock Input Data ---
const mockSheetTitle = 'Test Sheet <Title>'; 
const mockSheetID = 'TEST_SHEET_ID_123';
const mockRequestUrl = 'https://crssnt.com/sheetToRss?id=TEST_SHEET_ID_123&name=Sheet1&name=Sheet2';

const mockSheet1Values = [
    ['Title 1 (S1)', 'Desc A', 'https://example.com/1', '2025-04-02T09:00:00Z'], 
    ['Title 3 No Date (S1)', 'Desc C'], 
];
const mockSheet2Values = [
    ['Title 2 (S2)', 'Desc B', 'https://example.com/2', '2025-04-01T08:00:00Z'], 
    ['Title 4 Latest (S2)', 'Desc D', 'https://example.com/4', '2025-04-03T10:00:00Z'], 
];
const mockSheetValuesManual = [
    ['Title', 'URL', 'Summary', 'Published', 'Category', 'Author Name'], 
    ['Manual Title 1', 'https://example.com/m1', 'Manual Desc 1', '2025-04-01T12:00:00Z', 'Tech', 'Alice'], 
    ['Manual Title 2', 'https://example.com/m2', 'Manual Desc 2 & Special', '2025-04-02T12:00:00Z', 'News', 'Bob'], 
    ['Manual Title 3 No Date', 'https://example.com/m3', 'Manual Desc 3', '', 'Tech', 'Charlie'], 
];
const mockSingleSheetAutoData = { 'Sheet1': mockSheet1Values };
const mockSingleSheetManualData = { 'Sheet3': mockSheetValuesManual }; 
const mockMultiSheetAutoData = {
    'Sheet1': mockSheet1Values,
    'Sheet2': mockSheet2Values
};
const mockSheetValuesManualNoTitleValue = [
    ['Link', 'Description', 'Title', 'pubDate'], 
    ['https://example.com/item1', 'Desc 1', 'Valid Title 1', '2025-04-01T12:00:00Z'], 
    ['https://example.com/item2', 'Desc 2', '', '2025-04-02T12:00:00Z'], 
    ['https://example.com/item3', 'Desc 3', 'Valid Title 3', '2025-04-03T12:00:00Z'] 
];
const mockSheetValuesManualNoTitleHeader = [
    ['Link', 'Description', 'NotTheTitle', 'pubDate'], 
    ['https://example.com/item1', 'Desc 1', 'Some Value 1', '2025-04-01T12:00:00Z'],
    ['https://example.com/item2', 'Desc 2', 'Some Value 2', '2025-04-02T12:00:00Z']
];
const mockSheetValuesManualEmptyRow = [
    ['Title', 'Link'], 
    ['Valid Title 1', 'https://example.com/1'],
    ['', null], 
    ['  ', ' '], 
    ['Valid Title 2', 'https://example.com/2'],
];


// --- Tests for buildFeedData (Sheet processing) ---
describe('buildFeedData (Helper Function - Sheet Processing)', () => {

    describe('Auto Mode', () => {
        const mode = 'auto';
        const feedData = buildFeedData(mockSingleSheetAutoData, mode, mockSheetTitle, mockSheetID, mockRequestUrl);
        const items = feedData.items;

        it('should return the correct metadata structure', () => {
            expect(feedData.metadata.title).toBe(mockSheetTitle);
            expect(feedData.metadata.link).toBe(`https://docs.google.com/spreadsheets/d/${mockSheetID}`);
            expect(feedData.metadata.feedUrl).toBe(mockRequestUrl);
            expect(feedData.metadata.description).toBe('Feed from Google Sheet (auto mode). Generated by crssnt.');
            expect(feedData.metadata.id).toBe(`urn:google-sheet:${mockSheetID}`);
            const expectedLatestDate = parseISO('2025-04-02T09:00:00Z');
            expect(feedData.metadata.lastBuildDate.getTime()).toBe(expectedLatestDate.getTime());
        });

        it('should return the correct number of item objects', () => {
            expect(Array.isArray(items)).toBe(true);
            expect(items.length).toBe(2);
        });

        it('should sort items correctly by date (descending)', () => {
            expect(items[0].title).toBe('Title 1 (S1)'); 
            expect(items[1].title).toBe('Title 3 No Date (S1)'); 
        });
    });

    describe('Manual Mode', () => {
        const mode = 'manual';
        const feedData = buildFeedData(mockSingleSheetManualData, mode, mockSheetTitle, mockSheetID, mockRequestUrl);
        const items = feedData.items;

         it('should return the correct metadata structure', () => {
            expect(feedData.metadata.title).toBe(mockSheetTitle);
            expect(feedData.metadata.description).toBe('Feed from Google Sheet (manual mode). Generated by crssnt.');
            expect(feedData.metadata.lastBuildDate.getTime()).toBe(parseISO('2025-04-02T12:00:00Z').getTime());
        });

        it('should return the correct number of item objects', () => {
            expect(Array.isArray(items)).toBe(true);
            expect(items.length).toBe(3); 
        });

        it('should map aliases and custom headers to item properties (sorted)', () => {
            expect(items[0].title).toBe('Manual Title 2');
            expect(items[0].link).toBe('https://example.com/m2'); 
            expect(items[0].descriptionContent).toBe('Manual Desc 2 & Special'); 
            expect(items[0].dateObject?.toISOString()).toBe('2025-04-02T12:00:00.000Z'); 
            expect(items[0].customFields).toBeDefined();
            expect(items[0].customFields['Category']).toBe('News'); 
            expect(items[0].customFields['Author_Name']).toBe('Bob'); 

            expect(items[1].title).toBe('Manual Title 1');
            expect(items[1].dateObject?.toISOString()).toBe('2025-04-01T12:00:00.000Z');
            expect(items[1].customFields).toBeDefined();
            expect(items[1].customFields['Category']).toBe('Tech');
            expect(items[1].customFields['Author_Name']).toBe('Alice');

             expect(items[2].title).toBe('Manual Title 3 No Date');
             expect(items[2].dateObject).toBeNull();
             expect(items[2].customFields).toBeDefined();
             expect(items[2].customFields['Category']).toBe('Tech');
             expect(items[2].customFields['Author_Name']).toBe('Charlie');
        });

         it('should handle missing date in manual mode', () => {
             const feedDataNoDate = buildFeedData({ 'SheetX': mockSheetValuesManual }, mode, mockSheetTitle, mockSheetID, mockRequestUrl);
             const item3 = feedDataNoDate.items[2];
             expect(item3.title).toBe('Manual Title 3 No Date');
             expect(item3.link).toBe('https://example.com/m3');
             expect(item3.descriptionContent).toBe('Manual Desc 3');
             expect(item3.dateObject).toBeNull(); 
        });

        it('should use placeholder title if title value is missing in manual mode', () => {
            const feedDataNoTitleValue = buildFeedData({ 'SheetX': mockSheetValuesManualNoTitleValue }, mode, mockSheetTitle, mockSheetID, mockRequestUrl);
            const itemsNoTitleValue = feedDataNoTitleValue.items;

            expect(itemsNoTitleValue).toHaveLength(3);
            expect(itemsNoTitleValue[0].title).toBe('Valid Title 3'); 
            expect(itemsNoTitleValue[1].title).toBe('(Untitled)'); 
            expect(itemsNoTitleValue[2].title).toBe('Valid Title 1'); 

            const itemWithPlaceholder = itemsNoTitleValue[1]; 
            expect(itemWithPlaceholder.title).toBe('(Untitled)');
            expect(itemWithPlaceholder.link).toBe('https://example.com/item2');
            expect(itemWithPlaceholder.descriptionContent).toBe('Desc 2');
            expect(itemWithPlaceholder.dateObject?.toISOString()).toBe('2025-04-02T12:00:00.000Z');
        });

        it('should use placeholder title if "title" header is missing in manual mode', () => {
            const feedDataNoTitleHeader = buildFeedData({ 'SheetX': mockSheetValuesManualNoTitleHeader }, mode, mockSheetTitle, mockSheetID, mockRequestUrl);
            const itemsNoTitleHeader = feedDataNoTitleHeader.items;

            expect(itemsNoTitleHeader).toHaveLength(2);
            expect(itemsNoTitleHeader[0].title).toBe('(Untitled)');
            expect(itemsNoTitleHeader[0].link).toBe('https://example.com/item2'); 
            expect(itemsNoTitleHeader[0].dateObject?.toISOString()).toBe('2025-04-02T12:00:00.000Z');

            expect(itemsNoTitleHeader[1].title).toBe('(Untitled)');
            expect(itemsNoTitleHeader[1].link).toBe('https://example.com/item1');
            expect(itemsNoTitleHeader[1].dateObject?.toISOString()).toBe('2025-04-01T12:00:00.000Z');
        });

        it('should skip rows where all cells are empty or whitespace in manual mode', () => {
             const feedDataEmptyRows = buildFeedData({ 'SheetX': mockSheetValuesManualEmptyRow }, mode, mockSheetTitle, mockSheetID, mockRequestUrl);
             expect(feedDataEmptyRows.items).toHaveLength(2); 
             expect(feedDataEmptyRows.items[0].title).toBe('Valid Title 1'); 
             expect(feedDataEmptyRows.items[1].title).toBe('Valid Title 2'); 
        });
    });

    describe('Sheet Tab Aggregation - Auto Mode', () => {
        const mode = 'auto';
        const feedData = buildFeedData(mockMultiSheetAutoData, mode, mockSheetTitle, mockSheetID, mockRequestUrl);
        const items = feedData.items;

        it('should return combined metadata', () => {
            expect(feedData.metadata.title).toBe(mockSheetTitle);
            expect(feedData.metadata.description).toBe('Feed from Google Sheet (auto mode). Generated by crssnt.');
            const expectedLatestDate = parseISO('2025-04-03T10:00:00Z'); 
            expect(feedData.metadata.lastBuildDate.getTime()).toBe(expectedLatestDate.getTime());
        });

        it('should return the combined number of items from all sheets', () => {
             expect(Array.isArray(items)).toBe(true);
             expect(items.length).toBe(4);
        });

        it('should sort the COMBINED list of items correctly by date (descending)', () => {
            expect(items[0].title).toBe('Title 4 Latest (S2)'); 
            expect(items[1].title).toBe('Title 1 (S1)');         
            expect(items[2].title).toBe('Title 2 (S2)');         
            expect(items[3].title).toBe('Title 3 No Date (S1)'); 
        });
    });
});

// --- Tests for generateRssFeed, generateAtomFeed, generateJsonFeedObject, generateMarkdown ---

describe('generateRssFeed (Helper Function with Aggregated Sheet Data)', () => {
    const feedData = buildFeedData(mockMultiSheetAutoData, 'auto', mockSheetTitle, mockSheetID, mockRequestUrl);
    const resultXml = generateRssFeed(feedData);

    it('should contain channel metadata reflecting aggregation', () => {
        expect(resultXml).toContain(`<title>Test Sheet &lt;Title&gt;</title>`);
        expect(resultXml).toContain(`<description>Feed from Google Sheet (auto mode). Generated by crssnt.</description>`);
        const expectedDate = format(feedData.metadata.lastBuildDate, "EEE, dd MMM yyyy HH:mm:ss 'GMT'", { timeZone: 'GMT' });
        expect(resultXml).toContain(`<lastBuildDate>${expectedDate}</lastBuildDate>`);
    });

    it('should contain the correct total number of items', () => {
         expect(resultXml.match(/<item>/g)?.length).toBe(4);
    });

     it('should contain the latest item first', () => {
        const firstItem = feedData.items[0]; 
        const expectedDate = format(firstItem.dateObject, "EEE, dd MMM yyyy HH:mm:ss 'GMT'", { timeZone: 'GMT' });
        expect(resultXml).toContain(`<title><![CDATA[${firstItem.title}]]></title>`);
        expect(resultXml).toContain(`<pubDate>${expectedDate}</pubDate>`);
    });
});

describe('generateAtomFeed (Helper Function with Aggregated Sheet Data)', () => {
    const feedData = buildFeedData(mockMultiSheetAutoData, 'auto', mockSheetTitle, mockSheetID, mockRequestUrl);
    const resultXml = generateAtomFeed(feedData);

     it('should contain feed metadata reflecting aggregation', () => {
        expect(resultXml).toContain(`<title>Test Sheet &lt;Title&gt;</title>`);
        expect(resultXml).toContain(`<subtitle type="html"><![CDATA[Feed from Google Sheet (auto mode). Generated by crssnt.]]></subtitle>`);
        expect(resultXml).toContain(`<id>${feedData.metadata.id}</id>`); 
        expect(resultXml).toContain(`<updated>${formatISO(feedData.metadata.lastBuildDate)}</updated>`);
    });

    it('should contain the correct total number of entries', () => {
         expect(resultXml.match(/<entry>/g)?.length).toBe(4); 
    });

     it('should contain the latest entry first', () => {
        const firstItem = feedData.items[0]; 
        const expectedDate = formatISO(firstItem.dateObject);
        const expectedId = firstItem.link; 

        expect(resultXml).toContain('<entry>');
        expect(resultXml).toContain(`<title type="html"><![CDATA[${firstItem.title}]]></title>`);
        expect(resultXml).toContain(`<id>${escapeXmlMinimal(expectedId)}</id>`); 
        expect(resultXml).toContain(`<updated>${expectedDate}</updated>`);
        expect(resultXml).toContain('</entry>');
    });
});

describe('generateJsonFeedObject (Helper Function - Sheet Data)', () => {
    const mode = 'auto';
    const feedDataAggregated = buildFeedData(mockMultiSheetAutoData, mode, mockSheetTitle, mockSheetID, mockRequestUrl);
    const resultJson = generateJsonFeedObject(feedDataAggregated);

    it('should contain correct top-level feed properties for aggregated data', () => {
        expect(resultJson.version).toBe('https://jsonfeed.org/version/1.1');
        expect(resultJson.title).toBe(mockSheetTitle); 
        expect(resultJson.home_page_url).toBe(`https://docs.google.com/spreadsheets/d/${mockSheetID}`);
        expect(resultJson.feed_url).toBe(mockRequestUrl);
        expect(resultJson.description).toBe('Feed from Google Sheet (auto mode). Generated by crssnt.');
    });

    it('should contain the correct total number of items', () => {
        expect(Array.isArray(resultJson.items)).toBe(true);
        expect(resultJson.items.length).toBe(4); 
    });

    it('should contain correct properties for the latest item', () => {
        const firstItem = feedDataAggregated.items[0]; 
        const jsonItem = resultJson.items[0];

        expect(jsonItem.id).toBe(firstItem.link); 
        expect(jsonItem.url).toBe(firstItem.link);
        expect(jsonItem.title).toBe(firstItem.title);
        expect(jsonItem.content_html).toBe(firstItem.descriptionContent);
        expect(jsonItem.date_published).toBe(formatISO(firstItem.dateObject));
    });
     it('should handle items with no link (generate hashed ID)', () => {
        const itemNoLinkNoDate = feedDataAggregated.items.find(item => item.title === 'Title 3 No Date (S1)');
        const jsonItem = resultJson.items.find(jItem => jItem.title === 'Title 3 No Date (S1)');

        expect(jsonItem).toBeDefined();
        expect(itemNoLinkNoDate).toBeDefined();
        expect(jsonItem.url).toBeUndefined(); 
        expect(jsonItem.title).toBe('Title 3 No Date (S1)');
        expect(jsonItem.content_html).toBe('Desc C');
        expect(jsonItem.id).toMatch(/^urn:google-sheet:TEST_SHEET_ID_123:[a-f0-9]{40}$/);
    });
    it('should include custom fields under _crssnt_custom_fields for manual mode', () => {
        const manualFeedData = buildFeedData(mockSingleSheetManualData, 'manual', 'Manual Sheet', 'MANUAL_ID', 'https://crssnt.com/manual');
        const manualJson = generateJsonFeedObject(manualFeedData);
        const itemWithCustom = manualJson.items.find(item => item.title === 'Manual Title 2');
        expect(itemWithCustom).toBeDefined();
        expect(itemWithCustom._crssnt_custom_fields).toBeDefined();
        expect(itemWithCustom._crssnt_custom_fields.Category).toBe('News');
        expect(itemWithCustom._crssnt_custom_fields.Author_Name).toBe('Bob'); 
    });
    it('should include truncation notice in description if items are limited', () => {
        const limitedFeedData = buildFeedData(mockMultiSheetAutoData, 'auto', mockSheetTitle, mockSheetID, mockRequestUrl, 1, 500); 
        const limitedJson = generateJsonFeedObject(limitedFeedData);
        expect(limitedJson.description).toContain('Note: This feed may be incomplete due to configured limits.');
    });
});

describe('generateMarkdown (Helper Function - Sheet Data)', () => {
    const mode = 'auto';
    const feedDataAggregated = buildFeedData(mockMultiSheetAutoData, mode, mockSheetTitle, mockSheetID, mockRequestUrl);
    const resultMd = generateMarkdown(feedDataAggregated);

    it('should contain the correct total number of items (indicated by separators)', () => {
        const separatorCount = (resultMd.match(/\n---\n\n/g) || []).length;
        expect(separatorCount).toBe(feedDataAggregated.items.length + 1); 
    });

    it('should contain correct content for the latest item', () => {
        const firstItem = feedDataAggregated.items[0]; 
        const expectedPublishedDate = format(firstItem.dateObject, 'PPPppp', { timeZone: 'GMT' });

        expect(resultMd).toContain(`## ${escapeMarkdown(firstItem.title)}`);
        expect(resultMd).toContain(`*Published: ${expectedPublishedDate} (GMT)*`);
        expect(resultMd).toContain(firstItem.descriptionContent);
    });
    it('should handle items with no link and no date correctly', () => {
        const itemNoLinkNoDate = feedDataAggregated.items.find(item => item.title === 'Title 3 No Date (S1)');
        const expectedMarkdownTitle = escapeMarkdown(itemNoLinkNoDate.title);
        expect(resultMd).toContain(`## ${expectedMarkdownTitle}`);
        expect(resultMd).not.toContain(`## ${expectedMarkdownTitle}\n\n*Published:`);
        const regexEscapedMarkdownTitle = expectedMarkdownTitle.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const itemSectionRegex = new RegExp(`## ${regexEscapedMarkdownTitle}[\\s\\S]*?---`);
        const itemSectionMatch = resultMd.match(itemSectionRegex);
        expect(itemSectionMatch).toBeTruthy();
        expect(itemSectionMatch[0]).not.toContain("**Link:**");
        expect(resultMd).toContain(itemNoLinkNoDate.descriptionContent);
    });
    it('should include custom fields correctly for manual mode', () => {
        const manualFeedData = buildFeedData(mockSingleSheetManualData, 'manual', 'Manual Sheet', 'MANUAL_ID', 'https://crssnt.com/manual');
        const manualMd = generateMarkdown(manualFeedData);
        const itemTitle2 = 'Manual Title 2';
        const escapedItemTitle2 = escapeMarkdown(itemTitle2); 
        const regexEscapedItemTitle2 = escapedItemTitle2.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const item2SectionRegex = new RegExp(`## ${regexEscapedItemTitle2}[\\s\\S]*?---`);
        const item2SectionMatch = manualMd.match(item2SectionRegex);
        expect(item2SectionMatch).toBeTruthy();
        const item2Md = item2SectionMatch[0];
        expect(item2Md).toContain(`**Custom Fields:**`); 
        expect(item2Md).toContain(`* ${escapeMarkdown('Category')}: ${escapeMarkdown('News')}`);
        expect(item2Md).toContain(`* ${escapeMarkdown('Author_Name')}: ${escapeMarkdown('Bob')}`);
    });
    it('should include truncation notice if items are limited', () => {
        const limitedFeedData = buildFeedData(mockMultiSheetAutoData, 'auto', mockSheetTitle, mockSheetID, mockRequestUrl, 1, 500); 
        const limitedMd = generateMarkdown(limitedFeedData);
        expect(limitedMd).toContain(`**Note: This feed may be incomplete due to configured limits.**`);
    });
    it('should handle empty items list gracefully', () => {
        const emptyFeedData = {
            metadata: { title: 'Empty Feed', link: 'http://example.com', feedUrl: 'http://example.com/feed', description: 'An empty feed.' , lastBuildDate: MOCK_NOW_DATE, id:'urn:empty'},
            items: []
        };
        const md = generateMarkdown(emptyFeedData);
        expect(md).toContain("# Empty Feed");
        expect(md).toContain("_No items found._");
    });
});

// --- Mock XML Data for External Feed Parsing ---
const mockRssXmlFeed1 = `<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"><channel>
    <title>RSS Feed Alpha</title>
    <link>https://alpha.example.com</link>
    <description>Alpha items</description>
    <item>
      <title>Alpha Item 2 (Newer)</title>
      <link>https://alpha.example.com/item2</link>
      <description>Desc Alpha 2</description>
      <pubDate>Wed, 05 Apr 2025 10:00:00 GMT</pubDate>
      <guid>alpha2</guid>
    </item>
    <item>
      <title>Alpha Item 1 (Older)</title>
      <link>https://alpha.example.com/item1</link>
      <description>Desc Alpha 1</description>
      <pubDate>Mon, 03 Apr 2025 09:00:00 GMT</pubDate>
      <guid>alpha1</guid>
    </item>
</channel></rss>`;

const mockAtomXmlFeed2 = `<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Atom Feed Beta</title>
  <link href="https://beta.example.com" rel="alternate"/>
  <id>urn:beta</id>
  <updated>2025-04-06T12:00:00Z</updated>
  <entry>
    <title>Beta Item 1 (Newest)</title>
    <link href="https://beta.example.com/entry1"/>
    <id>beta1</id>
    <updated>2025-04-06T12:00:00Z</updated>
    <summary>Summary Beta 1</summary>
  </entry>
  <entry>
    <title>Beta Item 2 (Oldest)</title>
    <link href="https://beta.example.com/entry2"/>
    <id>beta2</id>
    <updated>2025-04-02T15:00:00Z</updated>
    <summary>Summary Beta 2</summary>
  </entry>
</feed>`;

const mockRssXmlFeed3NoDates = `<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"><channel>
    <title>Gamma Feed (No Dates)</title>
    <link>https://gamma.example.com</link>
    <item><title>Gamma Item 1</title><link>https://gamma.example.com/g1</link></item>
    <item><title>Gamma Item 2</title><link>https://gamma.example.com/g2</link></item>
</channel></rss>`;


// --- Tests for External Feed Processing (fetchUrlContent, parseXmlFeedWithCheerio, normalizeParsedFeed) ---

describe('fetchUrlContent', () => {
    const originalFetch = global.fetch;
    afterEach(() => {
        global.fetch = originalFetch; 
    });

    it('should fetch and return content for a successful response', async () => {
        global.fetch = jest.fn().mockResolvedValueOnce({
            ok: true,
            text: async () => 'Mocked fetched content',
        });
        const content = await fetchUrlContent('https://example.com/feed.xml');
        expect(fetch).toHaveBeenCalledWith('https://example.com/feed.xml', { headers: { 'User-Agent': 'crssnt-feed-generator/1.0 (+https://crssnt.com)' } });
        expect(content).toBe('Mocked fetched content');
    });

    it('should throw an error for a non-ok response', async () => {
        global.fetch = jest.fn().mockResolvedValueOnce({
            ok: false,
            status: 404,
            statusText: 'Not Found',
        });
        await expect(fetchUrlContent('https://example.com/notfound.xml'))
            .rejects.toThrow('Failed to fetch https://example.com/notfound.xml: 404 Not Found');
    });
});

describe('parseXmlFeedWithCheerio', () => {
    it('should parse a valid XML string and return a Cheerio object', () => {
        const $ = parseXmlFeedWithCheerio(mockRssXmlFeed1); // Use one of the new mocks
        expect($).toBeDefined();
        expect(typeof $.root).toBe('function'); 
        expect($('rss > channel > title').text()).toBe('RSS Feed Alpha');
    });
});

describe('normalizeParsedFeed', () => {
    const sourceUrl = 'https://example.com/source';

    describe('RSS Feed', () => {
        const $ = parseXmlFeedWithCheerio(mockRssXmlFeed1);
        const feedData = normalizeParsedFeed($, sourceUrl);

        it('should extract correct RSS metadata', () => {
            expect(feedData.metadata.title).toBe('RSS Feed Alpha');
            expect(feedData.metadata.link).toBe('https://alpha.example.com');
            expect(feedData.metadata.lastBuildDate.toISOString()).toBe(parseISO('2025-04-05T10:00:00Z').toISOString());
            expect(feedData.metadata.id).toBe('https://alpha.example.com'); // Fallback if no atom:link self
        });

        it('should extract and sort RSS items correctly', () => {
            expect(feedData.items).toHaveLength(2);
            expect(feedData.items[0].title).toBe('Alpha Item 2 (Newer)');
            expect(feedData.items[1].title).toBe('Alpha Item 1 (Older)');
        });
    });

    describe('Atom Feed', () => {
        const $ = parseXmlFeedWithCheerio(mockAtomXmlFeed2);
        const feedData = normalizeParsedFeed($, sourceUrl);

        it('should extract correct Atom metadata', () => {
            expect(feedData.metadata.title).toBe('Atom Feed Beta');
            expect(feedData.metadata.link).toBe('https://beta.example.com');
            expect(feedData.metadata.lastBuildDate.toISOString()).toBe(parseISO('2025-04-06T12:00:00Z').toISOString());
            expect(feedData.metadata.id).toBe('urn:beta');
        });

        it('should extract and sort Atom entries correctly', () => {
            expect(feedData.items).toHaveLength(2);
            expect(feedData.items[0].title).toBe('Beta Item 1 (Newest)');
            expect(feedData.items[1].title).toBe('Beta Item 2 (Oldest)');
        });
    });
     it('should handle unknown feed type gracefully', () => {
        const $ = parseXmlFeedWithCheerio('<data>not a feed</data>');
        const feedData = normalizeParsedFeed($, 'http://invalid.com/feed');
        expect(feedData.metadata.title).toBe('Unknown or Invalid Feed Type');
        expect(feedData.metadata.description).toContain('Could not determine feed type');
        expect(feedData.items).toHaveLength(0);
        expect(feedData.metadata.lastBuildDate).toBeNull(); // No dates to derive from
    });

    it('should use item date for lastBuildDate if feed date is missing', () => {
        const $ = parseXmlFeedWithCheerio(mockRssXmlFeed1); // mockRssXmlFeed1 has item dates
        const feedData = normalizeParsedFeed($, sourceUrl);
        expect(feedData.metadata.lastBuildDate.toISOString()).toBe(parseISO('2025-04-05T10:00:00Z').toISOString());
    });
});


// --- Tests for processMultipleUrls (Helper Function - URL Aggregation) ---
describe('processMultipleUrls (Helper Function - URL Aggregation)', () => {
    const mockRequestUrl = 'https://crssnt.com/feedToJson?url=...';
    let originalFetch;

    beforeEach(() => {
        originalFetch = global.fetch; 
    });
    afterEach(() => {
        global.fetch = originalFetch; 
        jest.clearAllMocks();
    });

    it('should combine and sort items from multiple valid feeds (no grouping)', async () => {
        global.fetch = jest.fn((url) => {
            if (url === 'https://alpha.example.com/rss.xml') return Promise.resolve({ ok: true, text: async () => mockRssXmlFeed1 });
            if (url === 'https://beta.example.com/atom.xml') return Promise.resolve({ ok: true, text: async () => mockAtomXmlFeed2 });
            return Promise.resolve({ ok: false, status: 404 });
        });

        const sourceUrls = ['https://alpha.example.com/rss.xml', 'https://beta.example.com/atom.xml'];
        const feedData = await processMultipleUrls(sourceUrls, mockRequestUrl, 50, 500, false); // groupByFeed = false
        
        expect(feedData.items).toHaveLength(4);
        expect(feedData.metadata.title).toBe('Combined Feed from 2 sources');
        expect(feedData.items[0].title).toBe('Beta Item 1 (Newest)');      
        expect(feedData.items[1].title).toBe('Alpha Item 2 (Newer)');     
        expect(feedData.items[2].title).toBe('Alpha Item 1 (Older)');     
        expect(feedData.items[3].title).toBe('Beta Item 2 (Oldest)');      
        expect(feedData.metadata.lastBuildDate.toISOString()).toBe(parseISO('2025-04-06T12:00:00Z').toISOString());
        expect(feedData.metadata.groupByFeed).toBe(false); 
        feedData.items.forEach(item => {
            expect(item.sourceInfo).toBeDefined(); 
        });
    });
    
    it('should combine items and set groupByFeed flag when requested, and not sort globally', async () => {
        global.fetch = jest.fn((url) => {
            if (url === 'https://alpha.example.com/rss.xml') return Promise.resolve({ ok: true, text: async () => mockRssXmlFeed1 }); // Alpha items: Apr 5, Apr 3
            if (url === 'https://beta.example.com/atom.xml') return Promise.resolve({ ok: true, text: async () => mockAtomXmlFeed2 });   // Beta items: Apr 6, Apr 2
            return Promise.resolve({ ok: false, status: 404 });
        });
        const sourceUrls = ['https://alpha.example.com/rss.xml', 'https://beta.example.com/atom.xml'];
        // When groupByFeed is true, items are concatenated in order of sourceUrls, then limited.
        // Sorting happens *within* normalizeParsedFeed for each individual feed.
        const feedData = await processMultipleUrls(sourceUrls, mockRequestUrl, 50, 500, true); // groupByFeed = true

        expect(feedData.items).toHaveLength(4); 
        expect(feedData.metadata.groupByFeed).toBe(true); 
        
        // Expected order if groupByFeed=true (items from alpha, then items from beta, each internally sorted)
        expect(feedData.items[0].title).toBe('Alpha Item 2 (Newer)'); // From Alpha, Apr 5
        expect(feedData.items[1].title).toBe('Alpha Item 1 (Older)'); // From Alpha, Apr 3
        expect(feedData.items[2].title).toBe('Beta Item 1 (Newest)');  // From Beta, Apr 6
        expect(feedData.items[3].title).toBe('Beta Item 2 (Oldest)');  // From Beta, Apr 2
        
        // lastBuildDate for grouped feed should be the latest of the individual feeds' lastBuildDates
        const expectedLastBuildDate = parseISO('2025-04-06T12:00:00Z'); // From Beta feed
        expect(feedData.metadata.lastBuildDate.getTime()).toBe(expectedLastBuildDate.getTime());

        feedData.items.forEach(item => {
            expect(item.sourceInfo).toBeDefined();
            expect(item.sourceInfo.title).toBeDefined();
            expect(item.sourceInfo.url).toBeDefined();
        });
    });

    it('should throw an error if all URLs fail or result in no items', async () => {
        global.fetch = jest.fn(() => Promise.resolve({ ok: false, status: 404, statusText: 'Not Found' }));
        const sourceUrls = ['https://fail1.example.com', 'https://fail2.example.com'];
        await expect(processMultipleUrls(sourceUrls, mockRequestUrl, 50, 500))
            .rejects.toThrow('No valid feed items could be fetched or processed from the provided URLs.');
    });
});

// --- Tests for Output Generators with Grouping ---
describe('generateJsonFeedObject with Grouping', () => {
    let feedDataWithMultipleSourcesUngrouped;
    let feedDataWithMultipleSourcesGrouped;
    const sourceUrl1 = 'https://alpha.example.com/rss.xml';
    const sourceUrl2 = 'https://beta.example.com/atom.xml';

    beforeAll(async () => { 
        global.fetch = jest.fn((url) => {
            if (url === sourceUrl1) return Promise.resolve({ ok: true, text: async () => mockRssXmlFeed1 });
            if (url === sourceUrl2) return Promise.resolve({ ok: true, text: async () => mockAtomXmlFeed2 });
            return Promise.resolve({ ok: false, status: 404 });
        });
        feedDataWithMultipleSourcesUngrouped = await processMultipleUrls([sourceUrl1, sourceUrl2], 'https://crssnt.com/combined', 50, 500, false);
        feedDataWithMultipleSourcesGrouped = await processMultipleUrls([sourceUrl1, sourceUrl2], 'https://crssnt.com/combined_grouped', 50, 500, true);
    });
    afterAll(() => {
        jest.restoreAllMocks(); 
    });


    it('should include _source_feed in items when metadata.groupByFeed is true', () => {
        // generateJsonFeedObject's groupByFeed param defers to feedData.metadata.groupByFeed
        const jsonResult = generateJsonFeedObject(feedDataWithMultipleSourcesGrouped); 
        expect(jsonResult.items).toHaveLength(4);
        expect(feedDataWithMultipleSourcesGrouped.metadata.groupByFeed).toBe(true);

        jsonResult.items.forEach(item => {
            expect(item._source_feed).toBeDefined();
            expect(item._source_feed.title).toBeDefined();
            expect(item._source_feed.url).toBeDefined();
            if (item.id === 'alpha1' || item.id === 'alpha2') {
                expect(item._source_feed.title).toBe('RSS Feed Alpha');
                expect(item._source_feed.url).toBe(sourceUrl1);
            } else if (item.id === 'beta1' || item.id === 'beta2') {
                expect(item._source_feed.title).toBe('Atom Feed Beta');
                expect(item._source_feed.url).toBe(sourceUrl2);
            }
        });
    });

    it('should NOT include _source_feed if metadata.groupByFeed is false', () => {
        const jsonResult = generateJsonFeedObject(feedDataWithMultipleSourcesUngrouped); 
        expect(feedDataWithMultipleSourcesUngrouped.metadata.groupByFeed).toBe(false);
        jsonResult.items.forEach(item => {
            expect(item._source_feed).toBeUndefined();
        });
    });
    
    it('should NOT include _source_feed if only one source, even if groupByFeed was requested (metadata.groupByFeed will be false)', async () => {
        const singleSourceData = await processMultipleUrls([sourceUrl1], 'https://crssnt.com/single', 50, 500, true); // Request grouping
        expect(singleSourceData.metadata.groupByFeed).toBe(false); // Effective grouping is false
        const jsonResult = generateJsonFeedObject(singleSourceData); 
        singleSourceData.items.forEach(item => {
            expect(item._source_feed).toBeUndefined();
        });
    });
});

describe('generateMarkdown with Grouping', () => {
    let feedDataWithMultipleSourcesUngrouped;
    let feedDataWithMultipleSourcesGrouped;
    const sourceUrl1 = 'https://alpha.example.com/rss.xml';
    const sourceUrl2 = 'https://beta.example.com/atom.xml';

    beforeAll(async () => {
        global.fetch = jest.fn((url) => {
            if (url === sourceUrl1) return Promise.resolve({ ok: true, text: async () => mockRssXmlFeed1 });
            if (url === sourceUrl2) return Promise.resolve({ ok: true, text: async () => mockAtomXmlFeed2 });
            return Promise.resolve({ ok: false, status: 404 });
        });
        feedDataWithMultipleSourcesUngrouped = await processMultipleUrls([sourceUrl1, sourceUrl2], 'https://crssnt.com/combined_md', 50, 500, false);
        feedDataWithMultipleSourcesGrouped = await processMultipleUrls([sourceUrl1, sourceUrl2], 'https://crssnt.com/combined_md_grouped', 50, 500, true);
    });
     afterAll(() => {
        jest.restoreAllMocks();
    });

    it('should group items under source feed headers when metadata.groupByFeed is true', () => {
        // generateMarkdown's groupByFeed param defers to feedData.metadata.groupByFeed
        const mdResult = generateMarkdown(feedDataWithMultipleSourcesGrouped); 
        expect(feedDataWithMultipleSourcesGrouped.metadata.groupByFeed).toBe(true);
        
        expect(mdResult).toContain(`## From: ${escapeMarkdown('RSS Feed Alpha')} ([${escapeMarkdown(sourceUrl1)}](${escapeMarkdown(sourceUrl1)}))`);
        expect(mdResult).toContain(`## From: ${escapeMarkdown('Atom Feed Beta')} ([${escapeMarkdown(sourceUrl2)}](${escapeMarkdown(sourceUrl2)}))`);

        const alphaSection = mdResult.substring(mdResult.indexOf('RSS Feed Alpha'), mdResult.indexOf('Atom Feed Beta'));
        const betaSection = mdResult.substring(mdResult.indexOf('Atom Feed Beta'));

        expect(alphaSection).toContain(`### ${escapeMarkdown('Alpha Item 2 (Newer)')}`);
        expect(alphaSection).toContain(`### ${escapeMarkdown('Alpha Item 1 (Older)')}`);
        expect(betaSection).toContain(`### ${escapeMarkdown('Beta Item 1 (Newest)')}`);
        expect(betaSection).toContain(`### ${escapeMarkdown('Beta Item 2 (Oldest)')}`);
    });

    it('should NOT group items if metadata.groupByFeed is false', () => {
        const mdResult = generateMarkdown(feedDataWithMultipleSourcesUngrouped); 
        expect(feedDataWithMultipleSourcesUngrouped.metadata.groupByFeed).toBe(false);

        expect(mdResult).not.toContain(`## From: ${escapeMarkdown('RSS Feed Alpha')}`);
        expect(mdResult).not.toContain(`## From: ${escapeMarkdown('Atom Feed Beta')}`);
        
        expect(mdResult).toContain(`### ${escapeMarkdown('Beta Item 1 (Newest)')}`);
        expect(mdResult).toContain(`### ${escapeMarkdown('Alpha Item 2 (Newer)')}`);
    });

    it('should NOT group items if only one source, (metadata.groupByFeed will be false)', async () => {
        const singleSourceData = await processMultipleUrls([sourceUrl1], 'https://crssnt.com/single_md', 50, 500, true); // Request grouping
        expect(singleSourceData.metadata.groupByFeed).toBe(false); // Effective grouping is false
        const mdResult = generateMarkdown(singleSourceData);
        expect(mdResult).not.toContain(`## From: ${escapeMarkdown('RSS Feed Alpha')}`);
        expect(mdResult).toContain(`### ${escapeMarkdown('Alpha Item 2 (Newer)')}`);
    });
});