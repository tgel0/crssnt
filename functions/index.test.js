// Import helper functions to be tested or used in tests
const { 
    buildFeedData, 
    generateRssFeed, 
    generateAtomFeed, 
    generateJsonFeedObject, 
    generateMarkdown,
    parseXmlFeedWithCheerio, 
    normalizeParsedFeed, 
    parseDateString,
    processMultipleUrls,
    escapeXmlMinimal // Added for testing generateRssFeed notices
} = require('./helper');
const { format, formatISO, parseISO } = require('date-fns');

// Define a fixed point in time for mocking 'now'
const MOCK_NOW_TIMESTAMP = new Date('2025-04-03T10:30:00.000Z').getTime();
const MOCK_NOW_DATE = new Date(MOCK_NOW_TIMESTAMP);

// Mock Date constructor and Date.now() for consistent fallback dates
beforeAll(() => {
  jest.useFakeTimers();
  jest.setSystemTime(MOCK_NOW_DATE);
});

afterAll(() => {
  jest.useRealTimers();
});

// --- Mock Input Data ---
const mockSheetTitle = 'Test Sheet <Title>'; 
const mockSheetID = 'TEST_SHEET_ID_123';
const mockRequestUrl = 'https://crssnt.com/sheetToRss?id=TEST_SHEET_ID_123&name=Sheet1&name=Sheet2';

const mockSheet1Values = [
    ['Title 1 (S1)', 'Desc A', 'https://example.com/1', '2025-04-02T09:00:00Z'], 
    ['Title 3 No Date (S1)', 'Desc C', undefined, null], 
    ['Title 5 Extra (S1)', 'Desc E', 'https://example.com/5', '2025-04-01T07:00:00Z'], // For itemLimit test
];
const mockSheet2Values = [
    ['Title 2 (S2)', 'Desc B', 'https://example.com/2', '2025-04-01T08:00:00Z'], 
    ['Title 4 Latest (S2)', 'Desc D', 'https://example.com/4', '2025-04-03T10:00:00Z'], 
    ['Title 6 Another (S2)', 'Desc F', 'https://example.com/6', '2025-03-30T10:00:00Z'], // For itemLimit test
];
const mockSheetValuesManual = [
    ['Title', 'URL', 'Summary', 'Published', 'Category', 'Author Name'], 
    ['Manual Title 1', 'https://example.com/m1', 'Manual Desc 1', '2025-04-01T12:00:00Z', 'Tech', 'Alice'], 
    ['Manual Title 2', 'https://example.com/m2', 'Manual Desc 2 & Special', '2025-04-02T12:00:00Z', 'News', 'Bob'], 
    ['Manual Title 3 No Date', 'https://example.com/m3', 'Manual Desc 3', '', 'Tech', 'Charlie'], 
    ['Manual Title 4 Extra', 'https://example.com/m4', 'Manual Desc 4', '2025-03-31T12:00:00Z', 'Tech', 'Dave'],
];
const mockSingleSheetAutoData = { 'Sheet1': mockSheet1Values };
const mockSingleSheetManualData = { 'Sheet3': mockSheetValuesManual }; 
const mockMultiSheetAutoData = {
    'Sheet1': mockSheet1Values, // 3 items
    'Sheet2': mockSheet2Values  // 3 items
};


// --- Tests for buildFeedData (Sheet processing) ---
describe('buildFeedData (Helper Function - Sheet Processing)', () => {
    describe('Auto Mode - Single Sheet', () => {
        const mode = 'auto';
        // mockSheet1Values has 3 items. Let's test with itemLimit = 2
        const feedData = buildFeedData(mockSingleSheetAutoData, mode, mockSheetTitle, mockSheetID, mockRequestUrl, 2);
        const items = feedData.items;

        it('should return the correct metadata structure', () => {
            expect(feedData.metadata.title).toBe(mockSheetTitle);
            expect(feedData.metadata.description).toBe('Feed from Google Sheet (auto mode). Generated by crssnt.');
            expect(feedData.metadata.id).toBe(`urn:google-sheet:${mockSheetID}`);
            // After limiting to 2, the newest 2 from Sheet1 are 'Title 1 (S1)' and 'Title 3 No Date (S1)'
            // 'Title 1 (S1)' is '2025-04-02T09:00:00Z'
            const expectedLatestDate = parseISO('2025-04-02T09:00:00Z');
            expect(feedData.metadata.lastBuildDate.getTime()).toBe(expectedLatestDate.getTime());
            expect(feedData.metadata.itemCountLimited).toBe(true); // Sheet1 had 3 items, limited to 2
            expect(feedData.metadata.isPreview).toBe(false); // Default
        });

        it('should apply itemLimit per sheet and return correct number of items', () => {
            expect(Array.isArray(items)).toBe(true);
            expect(items.length).toBe(2); // Limited from 3 to 2
        });

        it('should sort items correctly by date (descending) before limiting', () => {
            // Original Sheet1 items, sorted by date desc (nulls/invalid dates last):
            // 1. Title 1 (S1) (2025-04-02)
            // 2. Title 5 Extra (S1) (2025-04-01)
            // 3. Title 3 No Date (S1) (null date)
            // After limiting to 2, items should be Title 1 and Title 5.
            expect(items[0].title).toBe('Title 1 (S1)'); 
            expect(items[1].title).toBe('Title 5 Extra (S1)'); 
        });
    });

    describe('Manual Mode - Single Sheet', () => {
        const mode = 'manual';
        // mockSheetValuesManual has 4 items. itemLimit = 2
        const feedData = buildFeedData(mockSingleSheetManualData, mode, mockSheetTitle, mockSheetID, mockRequestUrl, 2);
        const items = feedData.items;

         it('should apply itemLimit and return correct metadata', () => {
            expect(feedData.metadata.title).toBe(mockSheetTitle);
            // Newest 2 from Manual: Manual Title 2 (Apr 2), Manual Title 1 (Apr 1)
            expect(feedData.metadata.lastBuildDate.getTime()).toBe(parseISO('2025-04-02T12:00:00Z').getTime());
            expect(feedData.metadata.itemCountLimited).toBe(true);
        });

        it('should return the correct number of item objects after per-sheet limiting', () => {
            expect(Array.isArray(items)).toBe(true);
            expect(items.length).toBe(2); // Limited from 4 to 2
        });

        it('should sort items correctly by date (descending) before limiting', () => {
            // Original Manual, sorted: MT2 (Apr2), MT1 (Apr1), MT4 (Mar31), MT3 (NoDate)
            // Limited to 2: MT2, MT1
            expect(items[0].title).toBe('Manual Title 2');
            expect(items[1].title).toBe('Manual Title 1');
        });
    });

    describe('Sheet Tab Aggregation - Auto Mode with itemLimit per sheet', () => {
        const mode = 'auto';
        // mockMultiSheetAutoData: Sheet1 (3 items), Sheet2 (3 items). itemLimit = 1 per sheet.
        const feedData = buildFeedData(mockMultiSheetAutoData, mode, mockSheetTitle, mockSheetID, mockRequestUrl, 1);
        const items = feedData.items; // Should be 1 from Sheet1 + 1 from Sheet2 = 2 items total

        it('should return combined metadata, reflecting per-sheet limits', () => {
            expect(feedData.metadata.title).toBe(mockSheetTitle);
            expect(feedData.metadata.itemCountLimited).toBe(true); // Both sheets were limited
            // Sheet1 newest: Title 1 (Apr 2). Sheet2 newest: Title 4 (Apr 3).
            // After global sort of these 2 items: Title 4, Title 1. So lastBuildDate is Apr 3.
            const expectedLatestDate = parseISO('2025-04-03T10:00:00Z'); 
            expect(feedData.metadata.lastBuildDate.getTime()).toBe(expectedLatestDate.getTime());
        });

        it('should return the combined number of items after per-sheet limiting', () => {
             expect(Array.isArray(items)).toBe(true);
             expect(items.length).toBe(2); // 1 from Sheet1 + 1 from Sheet2
        });

        it('should sort the GLOBALLY combined list of (per-sheet-limited) items correctly', () => {
            // Sheet1 newest (limit 1): Title 1 (S1) - Apr 2
            // Sheet2 newest (limit 1): Title 4 Latest (S2) - Apr 3
            // Combined and sorted: Title 4 Latest (S2), Title 1 (S1)
            expect(items[0].title).toBe('Title 4 Latest (S2)'); 
            expect(items[1].title).toBe('Title 1 (S1)');         
        });
    });

    describe('buildFeedData with isPreview flag', () => {
        it('should set metadata.isPreview to true when isPreview is passed as true', () => {
            const feedData = buildFeedData(mockSingleSheetAutoData, 'auto', mockSheetTitle, mockSheetID, mockRequestUrl, 2, 500, true);
            expect(feedData.metadata.isPreview).toBe(true);
        });

        it('should set metadata.isPreview to false when isPreview is passed as false', () => {
            const feedData = buildFeedData(mockSingleSheetAutoData, 'auto', mockSheetTitle, mockSheetID, mockRequestUrl, 2, 500, false);
            expect(feedData.metadata.isPreview).toBe(false);
        });

        it('should default metadata.isPreview to false when isPreview is not passed', () => {
            // buildFeedData defaults isPreview to false
            const feedData = buildFeedData(mockSingleSheetAutoData, 'auto', mockSheetTitle, mockSheetID, mockRequestUrl, 2, 500);
            expect(feedData.metadata.isPreview).toBe(false);
        });
    });

    describe('Filtering with sinceTimestamp', () => {
        const mode = 'auto';
        // mockMultiSheetAutoData has items from Apr 3, Apr 2, Apr 1, Mar 30, and two with no date.
        // Let's filter for items after Apr 1, 2025, 9am.
        const since = parseDateString('2025-04-01T09:00:00Z');
        const feedData = buildFeedData(mockMultiSheetAutoData, mode, mockSheetTitle, mockSheetID, mockRequestUrl, 50, 500, false, since);
        const items = feedData.items;

        it('should only return items published after the sinceTimestamp', () => {
            // Expected items:
            // Title 4 Latest (S2) - 2025-04-03T10:00:00Z
            // Title 1 (S1) - 2025-04-02T09:00:00Z
            expect(items).toHaveLength(2);
            expect(items[0].title).toBe('Title 4 Latest (S2)');
            expect(items[1].title).toBe('Title 1 (S1)');
        });

        it('should update lastBuildDate to the latest item in the filtered list', () => {
            const expectedLatestDate = parseISO('2025-04-03T10:00:00Z');
            expect(feedData.metadata.lastBuildDate.getTime()).toBe(expectedLatestDate.getTime());
        });
    });
});


describe('generateRssFeed (Helper Function with Aggregated Sheet Data)', () => {
    // Test with isPreview = false (default)
    const feedData = buildFeedData(mockMultiSheetAutoData, 'auto', mockSheetTitle, mockSheetID, mockRequestUrl, 50, 500, false);
    const resultXml = generateRssFeed(feedData);

    it('should contain channel metadata reflecting aggregation', () => {
        expect(resultXml).toContain(`<title>Test Sheet &lt;Title&gt;</title>`);
        // Description now includes a generic truncation note if applicable
        if (feedData.metadata.itemCountLimited || feedData.metadata.itemCharLimited) {
            expect(resultXml).toContain(`<description>Feed from Google Sheet (auto mode). Generated by crssnt. [Note: Feed content may be truncated due to limits.]</description>`);
        } else {
            expect(resultXml).toContain(`<description>Feed from Google Sheet (auto mode). Generated by crssnt.</description>`);
        }
        expect(resultXml).not.toContain('DEPRECATION NOTICE:');
        const expectedDate = format(feedData.metadata.lastBuildDate, "EEE, dd MMM yyyy HH:mm:ss 'GMT'", { timeZone: 'GMT' });
        expect(resultXml).toContain(`<lastBuildDate>${expectedDate}</lastBuildDate>`);
    });
});

describe('generateRssFeed with preview notice', () => {
    const baseMockFeedData = {
        metadata: {
            title: 'Test Feed',
            link: 'https://example.com',
            feedUrl: 'https://example.com/feed.xml',
            description: 'Original description.',
            lastBuildDate: MOCK_NOW_DATE,
            generator: 'Crssnt Test',
            id: 'test-id-123',
            itemCountLimited: false,
            itemCharLimited: false,
            isPreview: false
        },
        items: [
            { title: 'Item 1', descriptionContent: 'Desc 1', link: 'https://example.com/item1', dateObject: MOCK_NOW_DATE }
        ]
    };
    const deprecationNoticeText = "DEPRECATION NOTICE: This /preview endpoint is deprecated and will be removed in a future update. Please migrate to the v1/sheet/rss and v1/sheet/atom endpoints for continued service. ";

    it('should NOT include deprecation notice when metadata.isPreview is false', () => {
        const feedData = JSON.parse(JSON.stringify(baseMockFeedData)); // Deep clone
        feedData.metadata.isPreview = false;
        const xml = generateRssFeed(feedData);
        expect(xml).toContain(`<description>Original description.</description>`);
        expect(xml).not.toContain(deprecationNoticeText);
    });

    it('should include deprecation notice when metadata.isPreview is true', () => {
        const feedData = JSON.parse(JSON.stringify(baseMockFeedData));
        feedData.metadata.isPreview = true;
        const xml = generateRssFeed(feedData);
        const expectedDescription = deprecationNoticeText + "Original description.";
        expect(xml).toContain(`<description>${escapeXmlMinimal(expectedDescription)}</description>`);
    });

    it('should include deprecation notice AND truncation notice when both conditions met', () => {
        const feedData = JSON.parse(JSON.stringify(baseMockFeedData));
        feedData.metadata.isPreview = true;
        feedData.metadata.itemCountLimited = true; // or itemCharLimited = true
        const xml = generateRssFeed(feedData);
        const expectedDescription = deprecationNoticeText + "Original description." + ' [Note: Feed content may be truncated due to limits.]';
        expect(xml).toContain(`<description>${escapeXmlMinimal(expectedDescription)}</description>`);
    });

    it('should handle empty original description with preview notice', () => {
        const feedData = JSON.parse(JSON.stringify(baseMockFeedData));
        feedData.metadata.isPreview = true;
        feedData.metadata.description = ''; // Empty original description
        const xml = generateRssFeed(feedData);
        // The expected description is just the notice, as the original description is empty.
        expect(xml).toContain(`<description>${escapeXmlMinimal(deprecationNoticeText)}</description>`);
    });
});

describe('generateAtomFeed (Helper Function with Aggregated Sheet Data)', () => {
    const feedData = buildFeedData(mockMultiSheetAutoData, 'auto', mockSheetTitle, mockSheetID, mockRequestUrl);
    const resultXml = generateAtomFeed(feedData);

     it('should contain feed metadata reflecting aggregation', () => {
        expect(resultXml).toContain(`<title>Test Sheet &lt;Title&gt;</title>`);
        if (feedData.metadata.itemCountLimited || feedData.metadata.itemCharLimited) {
            expect(resultXml).toContain(`<subtitle type="html"><![CDATA[Feed from Google Sheet (auto mode). Generated by crssnt. [Note: Feed content may be truncated due to limits.]]]></subtitle>`);
        } else {
            expect(resultXml).toContain(`<subtitle type="html"><![CDATA[Feed from Google Sheet (auto mode). Generated by crssnt.]]></subtitle>`);
        }
        expect(resultXml).toContain(`<id>${feedData.metadata.id}</id>`); 
        expect(resultXml).toContain(`<updated>${formatISO(feedData.metadata.lastBuildDate)}</updated>`);
    });
});

describe('generateJsonFeedObject (Helper Function - Sheet Data)', () => {
    const mode = 'auto';
    const feedDataAggregated = buildFeedData(mockMultiSheetAutoData, mode, mockSheetTitle, mockSheetID, mockRequestUrl);
    const resultJson = generateJsonFeedObject(feedDataAggregated, false, false, false); 

    it('should contain correct top-level feed properties for aggregated data', () => {
        expect(resultJson.version).toBe('https://jsonfeed.org/version/1.1');
        expect(resultJson.title).toBe(mockSheetTitle); 
        if (feedDataAggregated.metadata.itemCountLimited || feedDataAggregated.metadata.itemCharLimited) {
            expect(resultJson.description).toBe('Feed from Google Sheet (auto mode). Generated by crssnt. Note: This feed may be incomplete due to configured limits.');
        } else {
            expect(resultJson.description).toBe('Feed from Google Sheet (auto mode). Generated by crssnt.');
        }
    });
});

describe('generateMarkdown (Helper Function - Sheet Data)', () => {
    const mode = 'auto';
    const feedDataAggregated = buildFeedData(mockMultiSheetAutoData, mode, mockSheetTitle, mockSheetID, mockRequestUrl);
    const resultMd = generateMarkdown(feedDataAggregated, false, false, false); 

    it('should include truncation notice if items are limited', () => {
        const limitedFeedData = buildFeedData(mockMultiSheetAutoData, 'auto', mockSheetTitle, mockSheetID, mockRequestUrl, 1, 500); 
        const limitedMd = generateMarkdown(limitedFeedData, false, false, false);
        expect(limitedMd).toContain(`**Note: Feed content may be truncated due to limits.**`);
    });
});

// --- Mock XML Data for External Feed Parsing ---
const mockRssXmlFeed1 = `<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"><channel>
    <title>RSS Feed Alpha</title>
    <link>https://alpha.example.com</link>
    <description>Alpha items</description>
    <item><title>Alpha Item 3 (Newest)</title><pubDate>Thu, 06 Apr 2025 10:00:00 GMT</pubDate><link>https://alpha.example.com/item3</link></item>
    <item><title>Alpha Item 2 (Newer)</title><pubDate>Wed, 05 Apr 2025 10:00:00 GMT</pubDate><link>https://alpha.example.com/item2</link></item>
    <item><title>Alpha Item 1 (Older)</title><pubDate>Mon, 03 Apr 2025 09:00:00 GMT</pubDate><link>https://alpha.example.com/item1</link></item>
</channel></rss>`; // 3 items

const mockAtomXmlFeed2 = `<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Atom Feed Beta</title>
  <updated>2025-04-07T12:00:00Z</updated>
  <entry><title>Beta Item 1 (Newest)</title><updated>2025-04-07T12:00:00Z</updated><link href="https://beta.example.com/entry1"/></entry>
  <entry><title>Beta Item 2 (Older)</title><updated>2025-04-04T15:00:00Z</updated><link href="https://beta.example.com/entry2"/></entry>
</feed>`; // 2 items

const mockRssXmlFeed3NoDates = `<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"><channel>
    <title>Gamma Feed (No Dates)</title>
    <item><title>Gamma Item 1</title><link>https://gamma.example.com/g1</link><description>Gamma desc 1</description></item>
    <item><title>Gamma Item 2</title><link>https://gamma.example.com/g2</link><description>Gamma desc 2</description></item>
</channel></rss>`;

const mockRssWithContentEncoded = `<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
<channel>
    <title>Content Encoded Feed</title>
    <item>
        <title>Test Item</title>
        <description>This is the short summary.</description>
        <content:encoded><![CDATA[<p>This is the <b>full</b> content.</p>]]></content:encoded>
    </item>
</channel>
</rss>`;

describe('normalizeParsedFeed with itemLimit', () => {
    it('should limit items from a single RSS feed', () => {
        const $ = parseXmlFeedWithCheerio(mockRssXmlFeed1); // 3 items
        const feedData = normalizeParsedFeed($, 'https://alpha.example.com/rss.xml', 1, 500); // itemLimit = 1
        expect(feedData.items).toHaveLength(1);
        expect(feedData.items[0].title).toBe('Alpha Item 3 (Newest)');
        expect(feedData.metadata.itemCountLimited).toBe(true);
    });
});

describe('processMultipleUrls (Helper Function - URL Aggregation & itemLimit per source)', () => {
    const mockRequestUrl = 'https://crssnt.com/feedToJson?url=...';
    let originalFetch;

    beforeEach(() => { originalFetch = global.fetch; });
    afterEach(() => { global.fetch = originalFetch; jest.clearAllMocks(); });

    it('should apply itemLimit per source and combine, then sort globally if not grouping', async () => {
        global.fetch = jest.fn((url) => {
            if (url === 'https://alpha.example.com/rss.xml') return Promise.resolve({ ok: true, text: async () => mockRssXmlFeed1 }); // 3 items
            if (url === 'https://beta.example.com/atom.xml') return Promise.resolve({ ok: true, text: async () => mockAtomXmlFeed2 });   // 2 items
            return Promise.resolve({ ok: false, status: 404 });
        });

        const sourceUrls = ['https://alpha.example.com/rss.xml', 'https://beta.example.com/atom.xml'];
        // itemLimit = 1 means 1 from Alpha, 1 from Beta. Total 2 items.
        const feedData = await processMultipleUrls(sourceUrls, mockRequestUrl, 1, 500, false); 
        
        expect(feedData.items).toHaveLength(2); // 1 from Alpha + 1 from Beta
        expect(feedData.metadata.itemCountLimited).toBe(true); // Because both Alpha and Beta were limited
        expect(feedData.metadata.title).toBe('Combined Feed from 2 sources (up to 1 items per source)');
        
        // Alpha newest (limit 1): Alpha Item 3 (Apr 6)
        // Beta newest (limit 1): Beta Item 1 (Apr 7)
        // Globally sorted: Beta Item 1, Alpha Item 3
        expect(feedData.items[0].title).toBe('Beta Item 1 (Newest)');      
        expect(feedData.items[1].title).toBe('Alpha Item 3 (Newest)');     
        expect(feedData.metadata.lastBuildDate.toISOString()).toBe(parseISO('2025-04-07T12:00:00Z').toISOString());
        expect(feedData.metadata.groupByFeed).toBe(false); 
    });
    
    it('should apply itemLimit per source and concatenate if grouping', async () => {
        global.fetch = jest.fn((url) => {
            if (url === 'https://alpha.example.com/rss.xml') return Promise.resolve({ ok: true, text: async () => mockRssXmlFeed1 }); 
            if (url === 'https://beta.example.com/atom.xml') return Promise.resolve({ ok: true, text: async () => mockAtomXmlFeed2 });   
            return Promise.resolve({ ok: false, status: 404 });
        });
        const sourceUrls = ['https://alpha.example.com/rss.xml', 'https://beta.example.com/atom.xml'];
        const feedData = await processMultipleUrls(sourceUrls, mockRequestUrl, 1, 500, true); // groupByFeed = true, itemLimit = 1

        expect(feedData.items).toHaveLength(2); // 1 from Alpha, 1 from Beta
        expect(feedData.metadata.groupByFeed).toBe(true); 
        expect(feedData.metadata.itemCountLimited).toBe(true);
        
        // Order is Alpha's newest, then Beta's newest (due to concatenation order)
        expect(feedData.items[0].title).toBe('Alpha Item 3 (Newest)'); 
        expect(feedData.items[1].title).toBe('Beta Item 1 (Newest)');  
        
        // lastBuildDate for grouped should be latest of the individual feed's lastBuildDates
        // Alpha's latest item is Apr 6, Beta's is Apr 7. So overall is Apr 7.
        const expectedLastBuildDate = parseISO('2025-04-07T12:00:00Z'); 
        expect(feedData.metadata.lastBuildDate.getTime()).toBe(expectedLastBuildDate.getTime());
    });

    it('should filter items globally based on sinceTimestamp', async () => {
        global.fetch = jest.fn((url) => {
            if (url === 'https://alpha.example.com/rss.xml') return Promise.resolve({ ok: true, text: async () => mockRssXmlFeed1 }); // Apr 6, Apr 5, Apr 3
            if (url === 'https://beta.example.com/atom.xml') return Promise.resolve({ ok: true, text: async () => mockAtomXmlFeed2 });   // Apr 7, Apr 4
            return Promise.resolve({ ok: false, status: 404 });
        });

        const sourceUrls = ['https://alpha.example.com/rss.xml', 'https://beta.example.com/atom.xml'];
        const since = parseDateString('2025-04-05T12:00:00Z'); // After Alpha Item 2
        // itemLimit is high to not interfere
        const feedData = await processMultipleUrls(sourceUrls, mockRequestUrl, 50, 500, false, since); 
        
        // Expected items: Beta Item 1 (Apr 7), Alpha Item 3 (Apr 6)
        expect(feedData.items).toHaveLength(2);
        expect(feedData.items[0].title).toBe('Beta Item 1 (Newest)');
        expect(feedData.items[1].title).toBe('Alpha Item 3 (Newest)');
        
        // lastBuildDate should be the newest of the filtered items
        expect(feedData.metadata.lastBuildDate.toISOString()).toBe(parseISO('2025-04-07T12:00:00Z').toISOString());
    });
});

// --- Tests for Output Generators with Grouping and LLM Compact Mode ---
describe('generateJsonFeedObject with LLM Compact Mode', () => {
    let feedDataMultiSourceGrouped;
    const sourceUrl1 = 'https://alpha.example.com/rss.xml';
    const sourceUrl2 = 'https://beta.example.com/atom.xml';

    beforeAll(async () => { 
        global.fetch = jest.fn((url) => {
            if (url === sourceUrl1) return Promise.resolve({ ok: true, text: async () => mockRssXmlFeed1 });
            if (url === sourceUrl2) return Promise.resolve({ ok: true, text: async () => mockAtomXmlFeed2 });
            return Promise.resolve({ ok: false, status: 404 });
        });
        feedDataMultiSourceGrouped = await processMultipleUrls([sourceUrl1, sourceUrl2], 'https://crssnt.com/combined_grouped', 2, 500, true); // itemLimit=2 per source
    });
    afterAll(() => {
        jest.restoreAllMocks(); 
    });


    it('should omit top-level metadata and item id in LLM compact mode', () => {
        const jsonResult = generateJsonFeedObject(feedDataMultiSourceGrouped, true, true, true); // isLlmCompact = true
        expect(jsonResult.title).toBeUndefined();
        expect(jsonResult.home_page_url).toBeUndefined();
        // ... (other top-level metadata checks)
        jsonResult.items.forEach(item => {
            expect(item.id).toBeUndefined(); 
            expect(item.date_published).toBeDefined(); 
            expect(item.content_text).toBeDefined();
        });
    });

    it('should include item title, url, content_text, and date_published in LLM compact mode', () => {
        const jsonResult = generateJsonFeedObject(feedDataMultiSourceGrouped, true, true, true);
        // With itemLimit=2 per source, and groupByFeed=true:
        // Alpha: Item3 (Apr 6), Item2 (Apr 5)
        // Beta: Item1 (Apr 7), Item2 (Apr 4)
        // First item in result is Alpha Item 3
        const firstItemOverall = jsonResult.items[0]; 
        expect(firstItemOverall.title).toBe('Alpha Item 3 (Newest)');
        expect(firstItemOverall.url).toBe('https://alpha.example.com/item3');
        // content_text is empty in mock for this item, so it will be empty string
        expect(firstItemOverall.content_text).toBe(''); 
        expect(firstItemOverall.date_published).toBe(formatISO(parseISO('2025-04-06T10:00:00Z')));
    });
    
    it('should include simplified _source_feed (title only) in LLM compact mode when grouped', () => {
        const jsonResult = generateJsonFeedObject(feedDataMultiSourceGrouped, true, true, true);
        expect(feedDataMultiSourceGrouped.metadata.groupByFeed).toBe(true);
        jsonResult.items.forEach(item => {
            expect(item._source_feed).toBeDefined();
            expect(item._source_feed.title).toBeDefined();
            expect(item._source_feed.url).toBeUndefined(); 
        });
    });
});

describe('generateMarkdown with LLM Compact Mode', () => {
    let feedDataMultiSourceGrouped, feedDataSingleSource, feedDataLimitedAndGrouped;
    const sourceUrl1 = 'https://alpha.example.com/rss.xml'; // 3 items
    const sourceUrl2 = 'https://beta.example.com/atom.xml';   // 2 items
    const sourceUrl3NoDate = 'https://gamma.example.com/rss.xml'; // 2 items, no dates

    beforeAll(async () => {
        global.fetch = jest.fn((url) => {
            if (url === sourceUrl1) return Promise.resolve({ ok: true, text: async () => mockRssXmlFeed1 });
            if (url === sourceUrl2) return Promise.resolve({ ok: true, text: async () => mockAtomXmlFeed2 });
            if (url === sourceUrl3NoDate) return Promise.resolve({ ok: true, text: async () => mockRssXmlFeed3NoDates });
            return Promise.resolve({ ok: false, status: 404 });
        });
        // groupByFeed = true, itemLimit = 2 per source
        feedDataMultiSourceGrouped = await processMultipleUrls([sourceUrl1, sourceUrl2], 'https://crssnt.com/combined_md_grouped', 2, 500, true); 
        // Test truncation with grouping (itemLimit=1 per source)
        feedDataLimitedAndGrouped = await processMultipleUrls([sourceUrl1, sourceUrl2], 'https://crssnt.com/limited_grouped', 1, 500, true);
        // Test no grouping
        feedDataSingleSource = await processMultipleUrls([sourceUrl3NoDate], 'https://crssnt.com/single_md', 50, 500, false); 
    });
     afterAll(() => {
        jest.restoreAllMocks();
    });

    it('should produce single-line hierarchical output when grouped and llm_compact is true', () => {
        const mdResult = generateMarkdown(feedDataMultiSourceGrouped, true, true, true); 
        // feedDataMultiSourceGrouped has itemLimit=2 per source.
        // Alpha: Item3 (Apr 6), Item2 (Apr 5)
        // Beta: Item1 (Apr 7), Item2 (Apr 4)
        // Since Alpha feed (3 items) is limited to 2, itemCountLimited is true for the combined feed.
        const expected =
            `# RSS Feed Alpha ## Alpha Item 3 (Newest) Link: https://alpha.example.com/item3 Date: ${formatISO(parseISO('2025-04-06T10:00:00Z'))} --- ## Alpha Item 2 (Newer) Link: https://alpha.example.com/item2 Date: ${formatISO(parseISO('2025-04-05T10:00:00Z'))}` +
            ` ||| # Atom Feed Beta ## Beta Item 1 (Newest) Link: https://beta.example.com/entry1 Date: ${formatISO(parseISO('2025-04-07T12:00:00Z'))} --- ## Beta Item 2 (Older) Link: https://beta.example.com/entry2 Date: ${formatISO(parseISO('2025-04-04T15:00:00Z'))}`;
        expect(mdResult).toBe(expected);
    });

    it('should produce single-line hierarchical output when not grouped and llm_compact is true', () => {
        const mdResult = generateMarkdown(feedDataSingleSource, false, false, true); 
        const expected = `# Gamma Item 1 Gamma desc 1 Link: https://gamma.example.com/g1 ||| # Gamma Item 2 Gamma desc 2 Link: https://gamma.example.com/g2`;
        expect(mdResult).toBe(expected);
    });

    it('should NOT include [TRUNCATED] notice in compact mode, even if items were limited', () => {
        // feedDataLimitedAndGrouped has itemLimit=1 per source. Both sources had more items.
        const mdResult = generateMarkdown(feedDataLimitedAndGrouped, true, true, true);
        const expected = 
            `# RSS Feed Alpha ## Alpha Item 3 (Newest) Link: https://alpha.example.com/item3 Date: ${formatISO(parseISO('2025-04-06T10:00:00Z'))}` + // Alpha Item 2 has no desc in mockRssXmlFeed1
            ` ||| # Atom Feed Beta ## Beta Item 1 (Newest) Link: https://beta.example.com/entry1 Date: ${formatISO(parseISO('2025-04-07T12:00:00Z'))}`; // Beta Item 1 has no desc in mockAtomXmlFeed2
        expect(mdResult).toBe(expected);
    });
});

describe('LLM Compact HTML Stripping', () => {
    let feedData;
    const sourceUrl = 'https://html.example.com/rss.xml';
    const mockRssWithHtmlDesc = `<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"><channel>
    <title>HTML Desc Feed</title>
    <item>
        <title>HTML Item</title>
        <link>https://html.example.com/item1</link>
        <description><![CDATA[<p>This is a <b>bold</b> description.</p> It has line breaks.<br/>And an <a href="http://example.com">anchor</a>.]]></description>
    </item>
</channel></rss>`;

    beforeAll(async () => {
        global.fetch = jest.fn((url) => {
            if (url === sourceUrl) return Promise.resolve({ ok: true, text: async () => mockRssWithHtmlDesc });
            return Promise.resolve({ ok: false, status: 404 });
        });
        feedData = await processMultipleUrls([sourceUrl], 'https://crssnt.com/html_test', 50, 500, false);
    });
    afterAll(() => {
        jest.restoreAllMocks();
    });

    it('generateMarkdown should strip HTML for llm_compact=true', () => {
        const mdResult = generateMarkdown(feedData, false, false, true);
        const expectedText = "# HTML Item This is a bold description. It has line breaks.And an anchor. Link: https://html.example.com/item1";
        expect(mdResult).toBe(expectedText);
    });

    it('generateJsonFeedObject should strip HTML for llm_compact=true', () => {
        const jsonResult = generateJsonFeedObject(feedData, false, false, true);
        const expectedDescription = "This is a bold description. It has line breaks.And an anchor.";
        expect(jsonResult.items[0].content_text).toBe(expectedDescription);
    });

    it('generateMarkdown should NOT strip HTML for llm_compact=false', () => {
        const mdResult = generateMarkdown(feedData, false, false, false);
        const originalDescription = `<p>This is a <b>bold</b> description.</p> It has line breaks.<br/>And an <a href="http://example.com">anchor</a>.`;
        expect(mdResult).toContain(originalDescription);
    });

    it('generateJsonFeedObject should NOT strip HTML for llm_compact=false', () => {
        const jsonResult = generateJsonFeedObject(feedData, false, false, false);
        const originalDescription = `<p>This is a <b>bold</b> description.</p> It has line breaks.<br/>And an <a href="http://example.com">anchor</a>.`;
        expect(jsonResult.items[0].content_text).toBe(originalDescription);
    });
});

describe('Content Prioritization and Cleaning', () => {
    it('should prioritize content:encoded over description for RSS feeds', () => {
        const $ = parseXmlFeedWithCheerio(mockRssWithContentEncoded);
        const feedData = normalizeParsedFeed($, 'https://content.example.com/rss', Infinity, Infinity);
        expect(feedData.items[0].descriptionContent).toBe('<p>This is the <b>full</b> content.</p>');
    });

    it('should clean and normalize whitespace from HTML in llm_compact mode', () => {
        const html = ` <p>  Hello   \n\n world. </p> <div>Another  line.</div> `;
        const expected = "Hello world. Another line.";
        const feedData = {
            metadata: { groupByFeed: false },
            items: [{ title: 'Test', descriptionContent: html }]
        };
        // Test Markdown output
        const mdResult = generateMarkdown(feedData, false, false, true);
        expect(mdResult).toContain(expected);
        expect(mdResult).not.toContain('  '); // Should not contain double spaces

        // Test JSON output
        const jsonResult = generateJsonFeedObject(feedData, false, false, true);
        expect(jsonResult.items[0].content_text).toBe(expected);
    });
});
